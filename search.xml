<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>array</title>
      <link href="/2023/08/19/array/"/>
      <url>/2023/08/19/array/</url>
      
        <content type="html"><![CDATA[<p>数组是存放在连续内存空间上的相同类型数据的集合</p><p>vector底层实现是array，严格讲vector是容器而不是数组</p><p>数组元素不能删除，只能覆盖</p><p>c++中二维数组在地址空间上是连续的</p><h3 id="一、二分查找"><a href="#一、二分查找" class="headerlink" title="一、二分查找"></a>一、二分查找</h3><p>给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target  ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1。</p><p>第一种写法：（左闭右闭）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">solution</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">search</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums,<span class="type">int</span> target)</span></span>&#123;</span><br><span class="line">            <span class="type">int</span> left = <span class="number">0</span>;</span><br><span class="line">            <span class="type">int</span> right = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>(left &lt;= right)&#123;<span class="comment">//左闭右闭区间，允许left=right</span></span><br><span class="line">                <span class="type">int</span> middle = (left + right) / <span class="number">2</span>;</span><br><span class="line">                <span class="keyword">if</span>(nums[middle] &gt; target)&#123;<span class="comment">//target在左区间，[left,middle-1]</span></span><br><span class="line">                    right = middle - <span class="number">1</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[middle] &lt; target)&#123;<span class="comment">//target在右区间,[middle+1,right]</span></span><br><span class="line">                    left = middle + <span class="number">1</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;<span class="comment">//target在middle处</span></span><br><span class="line">                    <span class="keyword">return</span> middle;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;<span class="comment">//目标值不存在</span></span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>第二种写法：（左闭右开）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">solution</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">search</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums,<span class="type">int</span> target)</span></span>&#123;</span><br><span class="line">            <span class="type">int</span> left = <span class="number">0</span>;</span><br><span class="line">            <span class="type">int</span> right = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">                <span class="type">int</span> middle = (left + right) / <span class="number">2</span>;</span><br><span class="line">                <span class="keyword">if</span>(nums[middle] &gt; target)&#123;</span><br><span class="line">                    right = middle;<span class="comment">//唯一不同之处在于target位于[left,middle)</span></span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[middle] &lt; target)&#123;<span class="comment">//[middle+1,right)</span></span><br><span class="line">                    left = middle + <span class="number">1</span>; </span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">return</span> middle;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>区间的定义就是不变量，那么在循环中坚持根据查找区间的定义来做边界处理，就是循环不变量规则。</p><h3 id="二、移除元素"><a href="#二、移除元素" class="headerlink" title="二、移除元素"></a>二、移除元素</h3><p>给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度。</p><p>暴力解法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">solution</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">removeElement</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums,<span class="type">int</span> val)</span></span>&#123;</span><br><span class="line">            <span class="type">int</span> size = nums.<span class="built_in">size</span>();</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; size;i ++)&#123;<span class="comment">//遍历数组</span></span><br><span class="line">                <span class="keyword">if</span>(nums[i] == val)&#123;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="type">int</span> j = i;j &lt; size - <span class="number">1</span>;j ++)&#123;<span class="comment">//执行移动操作</span></span><br><span class="line">                        nums[j] = nums[j + <span class="number">1</span>];<span class="comment">//后面元素覆盖前一个元素</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                i --;<span class="comment">//i下标后所有元素向前移动一位，i先减再加保持位置不变</span></span><br><span class="line">                size --;<span class="comment">//数组大小减一</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> size;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="双指针法"><a href="#双指针法" class="headerlink" title="双指针法"></a>双指针法</h3><p>通过一个快指针和一个慢指针在一个for循环下完成两个for循环的工作</p><ul><li>快指针：寻找新数组的元素，新数组就是不包含目标值的数组</li><li>慢指针：指向更新 新数组下标的位置</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">solution</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">removeElement</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums,<span class="type">int</span> val)</span></span>&#123;</span><br><span class="line">            <span class="type">int</span> slowIndex = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> fastIndex = <span class="number">0</span>;fastIndex &lt; nums.<span class="built_in">size</span>();fastIndex ++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[fastIndex] != val)&#123;<span class="comment">//快指针指向新数组值</span></span><br><span class="line">                    nums[slowIndex] = nums[fastIndex];<span class="comment">//将值赋给慢指针所指下标</span></span><br><span class="line">                    slowIndex ++;<span class="comment">//慢指针向右移动一位</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> slowIndex;<span class="comment">//删除完毕后慢指针下标所指值正好为新数组大小</span></span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="三、有序数组的平方"><a href="#三、有序数组的平方" class="headerlink" title="三、有序数组的平方"></a>三、有序数组的平方</h3><p>给你一个按 非递减顺序 排序的整数数组 nums，返回 每个数字的平方 组成的新数组，要求也按 非递减顺序 排序。</p><p>示例 1： 输入：nums = [-4,-1,0,3,10] 输出：[0,1,9,16,100] 解释：平方后，数组变为 [16,1,0,9,100]，排序后，数组变为 [0,1,9,16,100]</p><p>示例 2： 输入：nums = [-7,-3,2,3,11] 输出：[4,9,9,49,121]</p><p>暴力解法：(每个数平方之后排序)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">solution</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">sortedSquare</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span></span>&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; nums.<span class="built_in">size</span>();i ++)&#123;</span><br><span class="line">                nums[i] *= nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(),nums.<span class="built_in">end</span>());</span><br><span class="line">            <span class="keyword">return</span> nums;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="双指针法-1"><a href="#双指针法-1" class="headerlink" title="双指针法"></a>双指针法</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">solution</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">sortSquare</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span></span>&#123;</span><br><span class="line">            <span class="type">int</span> size = nums.<span class="built_in">size</span>();</span><br><span class="line">            <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">result</span><span class="params">(size,<span class="number">0</span>)</span></span>;</span><br><span class="line">            <span class="type">int</span> k = size - <span class="number">1</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>,j = size - <span class="number">1</span>;i &lt;= j;)&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[i] * nums[i] &lt; nums[j] * nums[j])&#123;</span><br><span class="line">                    result[k --] = nums[j] * nums[j];</span><br><span class="line">                    j --;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    result[k --] = nums[i] * nums[i];</span><br><span class="line">                    i ++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="四、长度最小的子数组"><a href="#四、长度最小的子数组" class="headerlink" title="四、长度最小的子数组"></a>四、长度最小的子数组</h3><p>给定一个含有 n 个正整数的数组和一个正整数 s ，找出该数组中满足其和 ≥ s 的长度最小的 连续 子数组，并返回其长度。如果不存在符合条件的子数组，返回 0。</p><p>暴力解法：</p><p>两层for循环，找到符合条件的子序列</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">solution</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">minSubArrayLen</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums,<span class="type">int</span> s)&#123;</span><br><span class="line">            <span class="type">int</span> size = nums.<span class="built_in">size</span>();</span><br><span class="line">            <span class="type">int</span> result = INT_MAX;<span class="comment">//记录最终结果</span></span><br><span class="line">           <span class="type">int</span> subLen = <span class="number">0</span>;<span class="comment">//记录子数组的长度</span></span><br><span class="line">            <span class="type">int</span> sum = <span class="number">0</span>;<span class="comment">//记录子数组和</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; size;i ++)&#123;<span class="comment">//子数组初始位置i</span></span><br><span class="line">                sum = <span class="number">0</span>;<span class="comment">//新子数组和要清零</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> j = i;j &lt; size;j ++)&#123;<span class="comment">//子数组终止位置j</span></span><br><span class="line">                    sum += nums[j];</span><br><span class="line">                    <span class="keyword">if</span>(sum &gt;= s)&#123;</span><br><span class="line">                        subLen = j - i + <span class="number">1</span>;<span class="comment">//子数组长度终止-初始+1</span></span><br><span class="line">                        result = result &lt; subLen ? result : subLen;<span class="comment">//保持结果长度最小</span></span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> result == INT_MAX ? <span class="number">0</span> : result;<span class="comment">//result未被赋值则返回0</span></span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h4><p>所谓滑动窗口，<strong>就是不断的调节子序列的起始位置和终止位置，从而得出我们要想的结果</strong>。</p><p>窗口就是 满足其和 ≥ s 的长度最小的 连续 子数组。</p><p>窗口的起始位置如何移动：如果当前窗口的值大于s了，窗口就要向前移动了（也就是该缩小了）。</p><p>窗口的结束位置如何移动：窗口的结束位置就是遍历数组的指针，也就是for循环里的索引。</p><p>动态调整子数组的初始位置：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(sum &gt;= s)&#123;</span><br><span class="line">subLen = j - i + <span class="number">1</span>;<span class="comment">//子数组长度</span></span><br><span class="line">    result = result &lt; subLen ? result : subLen;</span><br><span class="line">    sum -= nums[i ++];<span class="comment">//不断变更i（子数组的初始位置）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">solution</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minSubArrayLen</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums,<span class="type">int</span> s)</span></span>&#123;</span><br><span class="line">            <span class="type">int</span> result = INT_MAX;</span><br><span class="line">            <span class="type">int</span> subLen = <span class="number">0</span>;</span><br><span class="line">            <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>,j = <span class="number">0</span>;j &lt; nums.<span class="built_in">size</span>();j ++)&#123;</span><br><span class="line">                sum += nums[j];<span class="comment">//和&lt;s，向新数组加元素</span></span><br><span class="line">                <span class="keyword">while</span>(sum &gt;= s)&#123;</span><br><span class="line">                    subLen = j - i + <span class="number">1</span>;<span class="comment">//子数组长度</span></span><br><span class="line">                    result = result &lt; subLen ? result : subLen;</span><br><span class="line">                    sum -= nums[i ++];<span class="comment">//不断变更i（子数组的初始位置）</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> result == INT_MAX ? <span class="number">0</span> : result;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="螺旋矩阵"><a href="#螺旋矩阵" class="headerlink" title="螺旋矩阵"></a>螺旋矩阵</h3><p>给定一个正整数 n，生成一个包含 1 到 n^2 所有元素，且元素按顺时针顺序螺旋排列的正方形矩阵。</p><p>示例:</p><p>输入: 3 输出: [ [ 1, 2, 3 ], [ 8, 9, 4 ], [ 7, 6, 5 ] ]</p><p>遵循循环不变量原则</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">solution</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">generateMatrix</span>(<span class="type">int</span> n)&#123;</span><br><span class="line">            vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">res</span>(n,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n,<span class="number">0</span>));</span><br><span class="line">            <span class="type">int</span> startx = <span class="number">0</span>,starty = <span class="number">0</span>;</span><br><span class="line">            <span class="type">int</span> loop = n / <span class="number">2</span>;</span><br><span class="line">            <span class="type">int</span> mid = n / <span class="number">2</span>;</span><br><span class="line">            <span class="type">int</span> count = <span class="number">1</span>;</span><br><span class="line">            <span class="type">int</span> offset = <span class="number">1</span>;</span><br><span class="line">            <span class="type">int</span> i,j;</span><br><span class="line">            <span class="keyword">while</span>(loop --)&#123;</span><br><span class="line">                <span class="keyword">for</span>(j = starty;j &lt; n - offset;j ++)&#123;</span><br><span class="line">                    res[startx][j] = count ++;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">for</span>(i = startx;i &lt; n - offset;i ++)&#123;</span><br><span class="line">                    res[i][j] = count ++;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">for</span>(;j &gt; starty;j --)&#123;</span><br><span class="line">                    res[i][j] = count ++;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">for</span>(;i &gt; startx;i --)&#123;</span><br><span class="line">                    res[i][j] = count ++;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                startx ++;</span><br><span class="line">                starty ++;</span><br><span class="line">                offset ++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(n % <span class="number">2</span> == <span class="number">1</span>)&#123;</span><br><span class="line">                res[mid][mid] = n * n;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><div class="note default simple"><p>binary-tree</p></div>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>binary tree</title>
      <link href="/2023/08/18/binary-tree/"/>
      <url>/2023/08/18/binary-tree/</url>
      
        <content type="html"><![CDATA[<h3 id="一、二叉树定义"><a href="#一、二叉树定义" class="headerlink" title="一、二叉树定义"></a>一、二叉树定义</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">TreeNode</span>&#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    TreeNode *left;</span><br><span class="line">    TreeNode *right;</span><br><span class="line">    <span class="built_in">TreeNode</span>(<span class="type">int</span> x)&#123;</span><br><span class="line">        val = x;</span><br><span class="line">        <span class="keyword">this</span>.left = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">this</span>.right = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TreeNode</span>&#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    TreeNode left;</span><br><span class="line">    TreeNode right;</span><br><span class="line">    TreeNode()&#123;&#125;</span><br><span class="line">    TreeNode(<span class="type">int</span> val)&#123;<span class="built_in">this</span>.val = val;&#125;</span><br><span class="line">    TreeNode(<span class="type">int</span> val,TreeNode left,TreeNode right)&#123;</span><br><span class="line">        <span class="built_in">this</span>.val = val;</span><br><span class="line">        <span class="built_in">this</span>.left = left;</span><br><span class="line">        <span class="built_in">this</span>.right = right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TreeNode</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_init_</span>(<span class="params">self,value</span>):</span><br><span class="line">        self.value = value</span><br><span class="line">        self.left = <span class="literal">None</span></span><br><span class="line">        self.right = <span class="literal">None</span></span><br></pre></td></tr></table></figure><h3 id="二、递归"><a href="#二、递归" class="headerlink" title="二、递归"></a>二、递归</h3><p>1、确定递归函数的参数和返回值</p><p>2、确定终止条件</p><p>3、确定单层递归的逻辑</p><p>递归的实现：每一次递归调用都会把函数的局部变量，参数值，返回地址等压入调用栈中，等递归返回时，从栈顶弹出上一次递归的各项参数。</p><h4 id="前序遍历（递归）"><a href="#前序遍历（递归）" class="headerlink" title="前序遍历（递归）"></a>前序遍历（递归）</h4><p>打印遍历节点的值，除此之外无需返回其他值，函数返回类型为void,参数vec存储节点的数值</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">traversal</span><span class="params">(TreeNode* cur,vector&lt;<span class="type">int</span>&gt;&amp; vec)</span></span></span><br></pre></td></tr></table></figure><p>本轮递归终止的条件是当前节点为空</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(cur == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br></pre></td></tr></table></figure><p>前序遍历按照左中右顺序，先取中节点的值（单层递归）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vec.<span class="built_in">push_back</span>(cur -&gt; val);<span class="comment">//中</span></span><br><span class="line"><span class="built_in">traversal</span>(cur -&gt; left,vec);<span class="comment">//左</span></span><br><span class="line"><span class="built_in">traversal</span>(cur -&gt; right,vec);<span class="comment">//右</span></span><br></pre></td></tr></table></figure><p>前序遍历总过程：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">solution</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">traversal</span><span class="params">(TreeNode* cur,vector&lt;<span class="type">int</span>&gt;&amp; vec)</span></span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(cur == <span class="literal">NULL</span>)</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                vec.<span class="built_in">push_back</span>(cur -&gt; val);</span><br><span class="line">                <span class="built_in">traversal</span>(cur -&gt; left,vec);</span><br><span class="line">                <span class="built_in">traversal</span>(cur -&gt; right,vec);</span><br><span class="line">            &#125;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">preordertraversal</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">            vector&lt;<span class="type">int</span>&gt; result;<span class="comment">//初始化一个vec</span></span><br><span class="line">            <span class="built_in">traversal</span>(root,result);<span class="comment">//从根节点开始遍历</span></span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="中序遍历（递归）"><a href="#中序遍历（递归）" class="headerlink" title="中序遍历（递归）"></a>中序遍历（递归）</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">traversal</span><span class="params">(TreeNode* cur,vector&lt;<span class="type">int</span>&gt;&amp; vec)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(cur == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">traversal</span>(cur -&gt; left,vec);</span><br><span class="line">    vec.<span class="built_in">push_back</span>(cur -&gt; val);</span><br><span class="line">    <span class="built_in">traversal</span>(cur -&gt; right,vec);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="后序遍历（递归）"><a href="#后序遍历（递归）" class="headerlink" title="后序遍历（递归）"></a>后序遍历（递归）</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">traversal</span><span class="params">(TreeNode* cur,vector&lt;<span class="type">int</span>&gt;&amp; vec)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(cur == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">traversal</span>(cur -&gt; left,vec);</span><br><span class="line">    <span class="built_in">traversal</span>(cur -&gt; right,vec);</span><br><span class="line">    vec.<span class="built_in">push_back</span>(cur -&gt; val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="三、迭代"><a href="#三、迭代" class="headerlink" title="三、迭代"></a>三、迭代</h3><h4 id="前序遍历（迭代）"><a href="#前序遍历（迭代）" class="headerlink" title="前序遍历（迭代）"></a>前序遍历（迭代）</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">solution</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">            stack&lt;TreeNode*&gt; s;</span><br><span class="line">            vector&lt;<span class="type">int</span>&gt; vec;</span><br><span class="line">            <span class="keyword">if</span>(root == <span class="literal">NULL</span>)</span><br><span class="line">                <span class="keyword">return</span> vec;</span><br><span class="line">            s.<span class="built_in">push</span>(root);</span><br><span class="line">            <span class="keyword">while</span>(!s.<span class="built_in">empty</span>())&#123;</span><br><span class="line">                TreeNode* node = s.<span class="built_in">top</span>();</span><br><span class="line">                s.<span class="built_in">pop</span>();</span><br><span class="line">                vec.<span class="built_in">push_back</span>(node -&gt; val);<span class="comment">//栈顶节点值加入vec</span></span><br><span class="line">                <span class="keyword">if</span>(node -&gt; right)<span class="comment">//先压入右节点，空节点不执行</span></span><br><span class="line">                    s.<span class="built_in">push</span>(node -&gt; right);</span><br><span class="line">                <span class="keyword">if</span>(node -&gt; left)<span class="comment">//后压入左节点，空节点不执行</span></span><br><span class="line">                    s.<span class="built_in">push</span>(node -&gt; left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> vec;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="后序遍历（迭代）"><a href="#后序遍历（迭代）" class="headerlink" title="后序遍历（迭代）"></a>后序遍历（迭代）</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">solution</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">Traversal</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">    stack&lt;TreeNode*&gt; s;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; vec;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> vec;</span><br><span class="line">        s.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="keyword">while</span>(!s.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            TreeNode* node = s.<span class="built_in">top</span>();</span><br><span class="line">            s.<span class="built_in">pop</span>();</span><br><span class="line">            vec.<span class="built_in">push_back</span>(node -&gt; val);</span><br><span class="line">            <span class="keyword">if</span>(node -&gt; left)</span><br><span class="line">                s.<span class="built_in">push</span>(node -&gt; left);</span><br><span class="line">            <span class="keyword">if</span>(node -&gt; right)</span><br><span class="line">                s.<span class="built_in">push</span>(node -&gt; right);<span class="comment">//遍历顺序改为中右左</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">reverse</span>(vec.<span class="built_in">begin</span>(),vec.<span class="built_in">end</span>());<span class="comment">//逆序为左右中</span></span><br><span class="line">        <span class="keyword">return</span> vec;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>前序遍历访问节点（遍历节点）和处理节点（将节点放入vec数组中）可以进行同步处理（既处理顺序和访问顺序一致），但是中序遍历无法同步</p><h4 id="中序遍历（迭代）"><a href="#中序遍历（迭代）" class="headerlink" title="中序遍历（迭代）"></a>中序遍历（迭代）</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">solution</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">            vector&lt;<span class="type">int</span>&gt; vec;</span><br><span class="line">            stack&lt;TreeNode*&gt; s;</span><br><span class="line">            <span class="keyword">if</span>(root == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> vec;</span><br><span class="line">            TreeNode* cur = root;<span class="comment">//使用指针来进行节点访问</span></span><br><span class="line">            <span class="keyword">while</span>(!s.<span class="built_in">empty</span>())&#123;</span><br><span class="line">                <span class="keyword">if</span>(cur != <span class="literal">NULL</span>)&#123;<span class="comment">//指针访问节点，一直访问至二叉树最底层</span></span><br><span class="line">                    s.<span class="built_in">push</span>(cur);<span class="comment">//将访问节点放入栈</span></span><br><span class="line">                    cur = cur -&gt; left;<span class="comment">//左</span></span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    cur = s.<span class="built_in">top</span>();<span class="comment">//从栈顶弹出的数据即为需要处理的数据（放进vec数组中的数据）</span></span><br><span class="line">                    s.<span class="built_in">pop</span>();</span><br><span class="line">                    vec.<span class="built_in">push_back</span>(cur -&gt; val);<span class="comment">//中</span></span><br><span class="line">                    cur = cur -&gt; right;<span class="comment">//右</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>中序遍历先是访问根节点，再逐步向左向下访问节点直至到达最底层，进而再开始处理节点（将节点数值放入vec数组），导致访问顺序和处理数据顺序是不一样的。</p><h3 id="四、二叉树的统一迭代法"><a href="#四、二叉树的统一迭代法" class="headerlink" title="四、二叉树的统一迭代法"></a>四、二叉树的统一迭代法</h3><h4 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">solution</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">            vector&lt;<span class="type">int</span>&gt; vec;</span><br><span class="line">            stack&lt;TreeNode*&gt; s;</span><br><span class="line">            <span class="keyword">if</span>(root != <span class="literal">NULL</span>)</span><br><span class="line">                s.<span class="built_in">push</span>(root);</span><br><span class="line">            <span class="keyword">while</span>(!s.<span class="built_in">empty</span>())&#123;</span><br><span class="line">                TreeNode* node = s.<span class="built_in">top</span>();<span class="comment">//将该节点弹出，避免重复操作，下面再将右中左节点加入栈</span></span><br><span class="line">                <span class="keyword">if</span>(node != <span class="literal">NULL</span>)&#123;</span><br><span class="line">                    s.<span class="built_in">pop</span>();</span><br><span class="line">                    <span class="keyword">if</span>(node -&gt; right)</span><br><span class="line">                        s.<span class="built_in">push</span>(node -&gt; right);<span class="comment">//非空右节点入栈</span></span><br><span class="line">                    s.<span class="built_in">push</span>(node);<span class="comment">//中节点入栈</span></span><br><span class="line">                    s.<span class="built_in">push</span>(<span class="literal">NULL</span>);<span class="comment">//此时中节点未进行处理，再其后加入NULL标记（表示待处理）</span></span><br><span class="line">                    <span class="keyword">if</span>(node -&gt; left)</span><br><span class="line">                        s.<span class="built_in">push</span>(node -&gt; left);<span class="comment">//非空左节点入栈</span></span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;<span class="comment">//遇到空节点（即NULL标记）时，将下一个节点加入vec数组</span></span><br><span class="line">                    s.<span class="built_in">pop</span>();<span class="comment">//将空节点弹出</span></span><br><span class="line">                    node = s.<span class="built_in">top</span>();<span class="comment">//重新取出栈中元素</span></span><br><span class="line">                    s.<span class="built_in">pop</span>();</span><br><span class="line">                    vec.<span class="built_in">push_back</span>(node -&gt; val);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> vec;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="前序遍历"><a href="#前序遍历" class="headerlink" title="前序遍历"></a>前序遍历</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">solution</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">            vector&lt;<span class="type">int</span>&gt; vec;</span><br><span class="line">            stack&lt;TreeNode*&gt; s;</span><br><span class="line">            <span class="keyword">if</span>(root != <span class="literal">NULL</span>)</span><br><span class="line">                s.<span class="built_in">push</span>(root);</span><br><span class="line">            <span class="keyword">while</span>(!s.<span class="built_in">empty</span>())&#123;</span><br><span class="line">                TreeNode* node = s.<span class="built_in">top</span>();</span><br><span class="line">                <span class="keyword">if</span>(node != <span class="literal">NULL</span>)&#123;</span><br><span class="line">                    s.<span class="built_in">pop</span>();</span><br><span class="line">                    <span class="keyword">if</span>(node -&gt; right)</span><br><span class="line">                        s.<span class="built_in">push</span>(node -&gt; right);</span><br><span class="line">                    <span class="keyword">if</span>(node -&gt; left)</span><br><span class="line">                        s.<span class="built_in">push</span>(node -&gt; left);</span><br><span class="line">                    s.<span class="built_in">push</span>(node);</span><br><span class="line">                    s.<span class="built_in">push</span>(<span class="literal">NULL</span>)</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    s.<span class="built_in">pop</span>();</span><br><span class="line">                    node = s.<span class="built_in">top</span>();</span><br><span class="line">                    s.<span class="built_in">pop</span>();</span><br><span class="line">                    vec.<span class="built_in">push_back</span>(node -&gt; val);</span><br><span class="line">                &#125;</span><br><span class="line">                    </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">solution</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">Traversal</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; vec;</span><br><span class="line">        stack&lt;TreeNode*&gt; s;</span><br><span class="line">        <span class="keyword">if</span>(root != <span class="literal">NULL</span>)</span><br><span class="line">            s.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="keyword">while</span>(!s.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            TreeNode* node = s.<span class="built_in">top</span>();</span><br><span class="line">            <span class="keyword">if</span>(node != <span class="literal">NULL</span>)&#123;</span><br><span class="line">                s.<span class="built_in">pop</span>();</span><br><span class="line">                s.<span class="built_in">push</span>(node);</span><br><span class="line">                s.<span class="built_in">push</span>(<span class="literal">NULL</span>);</span><br><span class="line">                <span class="keyword">if</span>(node -&gt; right)</span><br><span class="line">                    s.<span class="built_in">push</span>(node -&gt; right);</span><br><span class="line">                <span class="keyword">if</span>(node -&gt; left)</span><br><span class="line">                    s.<span class="built_in">push</span>(node -&gt; left);</span><br><span class="line">                </span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                s.<span class="built_in">pop</span>();</span><br><span class="line">                node = s.<span class="built_in">top</span>();</span><br><span class="line">                s.<span class="built_in">pop</span>();</span><br><span class="line">                vec.<span class="built_in">push_back</span>(node -&gt; val);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> vec;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>到此，我们就将前中后序三种遍历用统一的代码风格写出来，关键在于加入NULL标记来表示需要处理的元素。</p><h3 id="五、二叉树的层序遍历"><a href="#五、二叉树的层序遍历" class="headerlink" title="五、二叉树的层序遍历"></a>五、二叉树的层序遍历</h3><p>层序遍历一个二叉树，就是一层一层从左往右进行遍历二叉树，需要借助数据结构遍历来实现，队列先进先出，符合一层一层遍历的逻辑，而使用栈先进后出适合深度优先遍历即递归的逻辑。</p><p>层序遍历是图论里的广度优先遍历。</p><h4 id="1、自上而下的层序遍历"><a href="#1、自上而下的层序遍历" class="headerlink" title="1、自上而下的层序遍历"></a>1、自上而下的层序遍历</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">solution</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">levelOrder</span>(TreeNode* root)&#123;</span><br><span class="line">            queue&lt;TreeNode*&gt; que;</span><br><span class="line">            vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; result;<span class="comment">//每层一个数组，每行合起来则是二维数组</span></span><br><span class="line">            <span class="keyword">if</span>(root != <span class="literal">NULL</span>)</span><br><span class="line">                que.<span class="built_in">push</span>(root);</span><br><span class="line">            <span class="keyword">while</span>(!que.<span class="built_in">empty</span>())&#123;</span><br><span class="line">                <span class="type">int</span> size = que.<span class="built_in">size</span>();</span><br><span class="line">                vector&lt;<span class="type">int</span>&gt; vec;</span><br><span class="line">                <span class="comment">//使用固定大小的size，而不用que.size()，因为que.size()会不断变化</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; size;i ++)&#123;</span><br><span class="line">                    TreeNode* node = que.<span class="built_in">front</span>();</span><br><span class="line">                    que.<span class="built_in">pop</span>();</span><br><span class="line">                    vec.<span class="built_in">push_back</span>(node -&gt; val);</span><br><span class="line">                    <span class="keyword">if</span>(node -&gt; left)</span><br><span class="line">                        que.<span class="built_in">push</span>(node -&gt; left);</span><br><span class="line">                    <span class="keyword">if</span>(node -&gt; right)</span><br><span class="line">                        que.<span class="built_in">push</span>(node -&gt; right);</span><br><span class="line">                &#125;</span><br><span class="line">                result.<span class="built_in">push_back</span>(vec);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line">#递归法</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">solution</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">order</span><span class="params">(TreeNode* cur,vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; result,<span class="type">int</span> depth)</span></span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(cur == <span class="literal">nullptr</span>)</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            <span class="keyword">if</span>(result.<span class="built_in">size</span>() == depth)</span><br><span class="line">                result.<span class="built_in">push_back</span>(<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;());</span><br><span class="line">            result[depth].<span class="built_in">push_back</span>(cur -&gt; val);</span><br><span class="line">            <span class="built_in">order</span>(cur -&gt; left,result,depth + <span class="number">1</span>);</span><br><span class="line">            <span class="built_in">order</span>(cur -&gt; right,result,depth + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">levelorder</span>(TreeNode* root)&#123;</span><br><span class="line">            vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; result;</span><br><span class="line">            <span class="type">int</span> depth = <span class="number">0</span>;</span><br><span class="line">            <span class="built_in">order</span>(root,result,depth);</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="2、自底向上的层序遍历（将数组逆序然后输出）"><a href="#2、自底向上的层序遍历（将数组逆序然后输出）" class="headerlink" title="2、自底向上的层序遍历（将数组逆序然后输出）"></a>2、自底向上的层序遍历（将数组逆序然后输出）</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">solution</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">order</span>(TreeNode* root)&#123;</span><br><span class="line">            queue&lt;TreeNode*&gt; que;</span><br><span class="line">            vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; result;</span><br><span class="line">            <span class="keyword">if</span>(root != <span class="literal">NULL</span>)</span><br><span class="line">                que.<span class="built_in">push</span>(root);</span><br><span class="line">            <span class="keyword">while</span>(!que.<span class="built_in">empty</span>())&#123;</span><br><span class="line">                <span class="type">int</span> size = que.<span class="built_in">size</span>();</span><br><span class="line">                vector&lt;<span class="type">int</span>&gt; vec;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; size;i ++)&#123;</span><br><span class="line">                    TreeNode* node = que.<span class="built_in">front</span>();</span><br><span class="line">                    que.<span class="built_in">pop</span>();</span><br><span class="line">                    vec.<span class="built_in">push_back</span>(node -&gt; val);</span><br><span class="line">                    <span class="keyword">if</span>(node -&gt; left)</span><br><span class="line">                        vec.<span class="built_in">push</span>(node -&gt; left);</span><br><span class="line">                    <span class="keyword">if</span>(node -&gt; right)</span><br><span class="line">                        vec.<span class="built_in">push</span>(node -&gt; right);</span><br><span class="line">                &#125;</span><br><span class="line">                result.<span class="built_in">push_back</span>(vec);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">reserve</span>(result.<span class="built_in">begin</span>(),result.<span class="built_in">end</span>());<span class="comment">//反转数组</span></span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="3、二叉树的右视图（从右看二叉树所能得到的节点值）"><a href="#3、二叉树的右视图（从右看二叉树所能得到的节点值）" class="headerlink" title="3、二叉树的右视图（从右看二叉树所能得到的节点值）"></a>3、二叉树的右视图（从右看二叉树所能得到的节点值）</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">solution</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">rightSizeView</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">            queue&lt;TreeNode*&gt; que;</span><br><span class="line">            vector&lt;<span class="type">int</span>&gt; result;</span><br><span class="line">            <span class="keyword">if</span>(root != <span class="literal">NULL</span>)</span><br><span class="line">                que.<span class="built_in">push</span>(root);</span><br><span class="line">            <span class="keyword">while</span>(!que.<span class="built_in">empty</span>())&#123;</span><br><span class="line">                <span class="type">int</span> size = que.<span class="built_in">size</span>();</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; size;i ++)&#123;</span><br><span class="line">                    TreeNode* node = que.<span class="built_in">front</span>();</span><br><span class="line">                    que.<span class="built_in">pop</span>();</span><br><span class="line">                    <span class="keyword">if</span>(i ==<span class="built_in">z</span> (size - <span class="number">1</span>))</span><br><span class="line">                        result.<span class="built_in">push_back</span>(node -&gt; val);<span class="comment">//将每层最后一个元素放入result数组</span></span><br><span class="line">                    <span class="keyword">if</span>(node -&gt; left)</span><br><span class="line">                        que.<span class="built_in">push</span>(node -&gt;left);</span><br><span class="line">                    <span class="keyword">if</span>(node -&gt; right)</span><br><span class="line">                        que.<span class="built_in">push</span>(node -&gt;right);</span><br><span class="line">                &#125; </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="4、二叉树的层平均值"><a href="#4、二叉树的层平均值" class="headerlink" title="4、二叉树的层平均值"></a>4、二叉树的层平均值</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">solution</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">double</span>&gt; <span class="title">averageOfLevels</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">            queue&lt;TreeNode*&gt; que;</span><br><span class="line">            vector&lt;<span class="type">double</span>&gt; result;</span><br><span class="line">            <span class="keyword">if</span>(root != <span class="literal">NULL</span>)</span><br><span class="line">                que.<span class="built_in">push</span>(root);</span><br><span class="line">            <span class="keyword">while</span>(!que.<span class="built_in">empty</span>())&#123;</span><br><span class="line">                <span class="type">int</span> size = que.<span class="built_in">size</span>();</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; size;i ++)&#123;</span><br><span class="line">                    TreeNode* node = que.<span class="built_in">front</span>();</span><br><span class="line">                    que.<span class="built_in">pop</span>();</span><br><span class="line">                    <span class="type">double</span> sum += node -&gt; val;<span class="comment">//统计每一层的和</span></span><br><span class="line">                    <span class="keyword">if</span>(node -&gt; left)</span><br><span class="line">                        que.<span class="built_in">push</span>(node -&gt; left);</span><br><span class="line">                    <span class="keyword">if</span>(node -&gt; right)</span><br><span class="line">                        que.<span class="built_in">push</span>(node -&gt; right);</span><br><span class="line">                &#125;</span><br><span class="line">                result.<span class="built_in">push_back</span>(sum / size);<span class="comment">//将每一层均值放入result数组中</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="5、N叉树的层序遍历"><a href="#5、N叉树的层序遍历" class="headerlink" title="5、N叉树的层序遍历"></a>5、N叉树的层序遍历</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">solution</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">levelOrder</span>(TreeNode* root)&#123;</span><br><span class="line">            queue&lt;TreeNode*&gt; que;</span><br><span class="line">            vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; result;</span><br><span class="line">            <span class="keyword">if</span>(root != <span class="literal">NULL</span>)</span><br><span class="line">                que.<span class="built_in">push</span>(root);</span><br><span class="line">            <span class="keyword">while</span>(!que.<span class="built_in">empty</span>())&#123;</span><br><span class="line">                <span class="type">int</span> size = que.<span class="built_in">size</span>();</span><br><span class="line">                vector&lt;<span class="type">int</span>&gt; vec;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; size;i ++)&#123;</span><br><span class="line">                    TreeNode* node = que.<span class="built_in">front</span>();</span><br><span class="line">                    que.<span class="built_in">pop</span>();</span><br><span class="line">                    vec.<span class="built_in">push_back</span>(node -&gt; val);</span><br><span class="line">                    <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>;i &lt; node -&gt; children.<span class="built_in">size</span>();j ++)&#123;<span class="comment">//将节点孩子加入队列</span></span><br><span class="line">                        <span class="keyword">if</span>(node -&gt; children[j])</span><br><span class="line">                            que.<span class="built_in">push</span>(node -&gt; children[j]);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                result.<span class="built_in">push_back</span>(vec);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="6、在每个二叉树行中找最大值"><a href="#6、在每个二叉树行中找最大值" class="headerlink" title="6、在每个二叉树行中找最大值"></a>6、在每个二叉树行中找最大值</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">solution</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">largestValues</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">            queue&lt;TreeNode*&gt; que;</span><br><span class="line">            vector&lt;<span class="type">int</span>&gt; result;</span><br><span class="line">            <span class="keyword">if</span>(root != <span class="literal">NULL</span>)</span><br><span class="line">                que.<span class="built_in">push</span>(root);</span><br><span class="line">            <span class="keyword">while</span>(!que.<span class="built_in">empty</span>())&#123;</span><br><span class="line">                <span class="type">int</span> size = que.<span class="built_in">size</span>();</span><br><span class="line">                <span class="type">int</span> maxValue = INT_MIN;<span class="comment">//现将最大值设为INT_MIN(即整数最小)</span></span><br><span class="line">                <span class="keyword">for</span>(i = <span class="number">0</span>;i &lt; size;i ++)&#123;</span><br><span class="line">                    TreeNode* node = que.<span class="built_in">front</span>();</span><br><span class="line">                    <span class="comment">//通过每一层不断比较，最终得到maxValue（即最大值）</span></span><br><span class="line">                    maxValue = ((node -&gt; val) &gt; maxValue)?node -&gt; val:maxValue;</span><br><span class="line">                    <span class="keyword">if</span>(node -&gt; left)</span><br><span class="line">                        que.<span class="built_in">push</span>(node -&gt; left);</span><br><span class="line">                    <span class="keyword">if</span>(node -&gt; right)</span><br><span class="line">                        que.<span class="built_in">push</span>(node -&gt; right);</span><br><span class="line">                &#125;</span><br><span class="line">                result.<span class="built_in">push_back</span>(maxValue);<span class="comment">//将每一层的最大值加入数组result</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="7、填充每一个节点的下一个右侧节点"><a href="#7、填充每一个节点的下一个右侧节点" class="headerlink" title="7、填充每一个节点的下一个右侧节点"></a>7、填充每一个节点的下一个右侧节点</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span>&#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    Node* left;</span><br><span class="line">    Node* right;</span><br><span class="line">    Node* next;<span class="comment">//指向节点的右侧节点</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">solution</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">connect</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">            queue&lt;TreeNode*&gt; que;</span><br><span class="line">            <span class="keyword">if</span>(root != <span class="literal">NULL</span>)</span><br><span class="line">                que.<span class="built_in">push</span>(root);</span><br><span class="line">            <span class="keyword">while</span>(!que.<span class="built_in">empty</span>())&#123;</span><br><span class="line">                <span class="type">int</span> size = que.<span class="built_in">size</span>();</span><br><span class="line">                Node* preNode;<span class="comment">//用来记录首节点和前一个节点</span></span><br><span class="line">                Node* node;<span class="comment">//遍历节点</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; size;i ++)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(i == <span class="number">0</span>)&#123;</span><br><span class="line">                        preNode = que.<span class="built_in">front</span>();</span><br><span class="line">                        que.<span class="built_in">pop</span>();</span><br><span class="line">                        node = preNode;</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        node = que.<span class="built_in">front</span>();</span><br><span class="line">                        que.<span class="built_in">pop</span>();</span><br><span class="line">                        preNode -&gt; next = node;</span><br><span class="line">                        preNode  = preNode -&gt; next;<span class="comment">//= node同理</span></span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span>(node -&gt; left)</span><br><span class="line">                        que.<span class="built_in">push</span>(node -&gt; left);</span><br><span class="line">                    <span class="keyword">if</span>(node -&gt; right)</span><br><span class="line">                        que.<span class="built_in">push</span>(right);</span><br><span class="line">                &#125;</span><br><span class="line">                node -&gt; next = <span class="literal">NULL</span>;<span class="comment">//本层最后一个节点指向NULL</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="8、二叉树的最大深度"><a href="#8、二叉树的最大深度" class="headerlink" title="8、二叉树的最大深度"></a>8、二叉树的最大深度</h4><p>给定一个二叉树，找出其最大深度</p><p>二叉树的深度为根节点到最远叶子节点的最长路径上的节点数（叶子节点没有子节点）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">solution</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">        queue&lt;TreeNode*&gt; que;</span><br><span class="line">        <span class="type">int</span> depth = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(root != <span class="literal">NULL</span>)</span><br><span class="line">            que.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="keyword">while</span>(!que.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            <span class="type">int</span> size = que.<span class="built_in">size</span>();</span><br><span class="line">            depth ++;<span class="comment">//记录深度</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; size;i ++)&#123;</span><br><span class="line">                TreeNode* node = que.<span class="built_in">front</span>();</span><br><span class="line">                que.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="keyword">if</span>(node -&gt; left)</span><br><span class="line">                    que.<span class="built_in">push</span>(node -&gt; left);</span><br><span class="line">                <span class="keyword">if</span>(node -&gt; right)</span><br><span class="line">                    que.<span class="built_in">push</span>(node -&gt; right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> depth;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="9、二叉树的最小深度"><a href="#9、二叉树的最小深度" class="headerlink" title="9、二叉树的最小深度"></a>9、二叉树的最小深度</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">solution</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minDepth</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">            queue&lt;TreeNode*&gt; que;</span><br><span class="line">            <span class="type">int</span> depth = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span>(root != <span class="literal">NULL</span>)</span><br><span class="line">                que.<span class="built_in">push</span>(root);</span><br><span class="line">            <span class="keyword">while</span>(!que.<span class="built_in">empty</span>())&#123;</span><br><span class="line">                <span class="type">int</span> size = que.<span class="built_in">size</span>();</span><br><span class="line">                depth ++;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; size;i ++)&#123;</span><br><span class="line">                    TreeNode* node = que.<span class="built_in">front</span>();</span><br><span class="line">                    que.<span class="built_in">pop</span>();</span><br><span class="line">                    <span class="keyword">if</span>(node -&gt; left)</span><br><span class="line">                        que.<span class="built_in">push</span>(node -&gt; left);</span><br><span class="line">                    <span class="keyword">if</span>(node -&gt; right)</span><br><span class="line">                        que.<span class="built_in">push</span>(node -&gt; right);</span><br><span class="line">                    <span class="comment">//当节点左右孩子都为空（即叶子节点），到达最小深度</span></span><br><span class="line">                    <span class="keyword">if</span>(!node -&gt; left &amp;&amp; !node -&gt; right)</span><br><span class="line">                        <span class="keyword">return</span> depth;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> depth;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>总结，二叉树的层序遍历，就是图论中的广度优先搜索在二叉树中的应用，需要借助队列来实现。</p><h3 id="六、翻转二叉树"><a href="#六、翻转二叉树" class="headerlink" title="六、翻转二叉树"></a>六、翻转二叉树</h3><h4 id="1、深度优先遍历"><a href="#1、深度优先遍历" class="headerlink" title="1、深度优先遍历"></a>1、深度优先遍历</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//递归（前序遍历）</span></span><br><span class="line"><span class="comment">//先进行交换左右孩子节点，然后反转左子树，然后反转右子树</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">solution</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">invertTree</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(root == <span class="literal">NULL</span>)</span><br><span class="line">                <span class="keyword">return</span> root;</span><br><span class="line">            <span class="built_in">swap</span>(root -&gt; left,root -&gt; right);<span class="comment">//中</span></span><br><span class="line">            <span class="built_in">invertTree</span>(root -&gt; left);<span class="comment">//左</span></span><br><span class="line">            <span class="built_in">invertTree</span>(root -&gt; right);<span class="comment">//右</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//前序遍历（迭代）</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">solution</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">invertTree</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">            stack&lt;TreeNode*&gt; st;</span><br><span class="line">            <span class="keyword">if</span>(root != <span class="literal">NULL</span>)</span><br><span class="line">                st.<span class="built_in">push</span>(root);</span><br><span class="line">            <span class="keyword">while</span>(!st.<span class="built_in">empty</span>())&#123;</span><br><span class="line">                TreeNode* node = st.<span class="built_in">top</span>();<span class="comment">//中</span></span><br><span class="line">                st.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="built_in">swap</span>(node -&gt; left,node -&gt;right);</span><br><span class="line">                <span class="keyword">if</span>(node -&gt; right)</span><br><span class="line">                    st.<span class="built_in">push</span>(node -&gt; right);<span class="comment">//右</span></span><br><span class="line">                <span class="keyword">if</span>(node -&gt; left)</span><br><span class="line">                    st.<span class="built_in">push</span>(node -&gt; left);<span class="comment">//左</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//前序遍历（统一迭代法）</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">solution</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">invertTree</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">            stack&lt;TreeNode*&gt; st;</span><br><span class="line">            <span class="keyword">if</span>(root != <span class="literal">NULL</span>)</span><br><span class="line">                st.<span class="built_in">push</span>(root);</span><br><span class="line">            <span class="keyword">while</span>(!st.<span class="built_in">empty</span>())&#123;</span><br><span class="line">                TreeNode* node = st.<span class="built_in">top</span>();</span><br><span class="line">                <span class="keyword">if</span>(node != <span class="literal">NULL</span>)&#123;</span><br><span class="line">                    st.<span class="built_in">pop</span>();</span><br><span class="line">                    <span class="keyword">if</span>(node -&gt; right)</span><br><span class="line">                        st.<span class="built_in">push</span>(right);</span><br><span class="line">                    <span class="keyword">if</span>(node -&gt; left)</span><br><span class="line">                        st.<span class="built_in">push</span>(left);</span><br><span class="line">                    st.<span class="built_in">push</span>(node);</span><br><span class="line">                    st.<span class="built_in">push</span>(<span class="literal">NULL</span>);</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    st.<span class="built_in">pop</span>();</span><br><span class="line">                    TreeNode* node = st.<span class="built_in">top</span>();</span><br><span class="line">                    st.<span class="built_in">pop</span>();</span><br><span class="line">                    <span class="built_in">swap</span>(node -&gt; left,node -&gt;right);<span class="comment">//节点处理逻辑</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="2、广度优先遍历"><a href="#2、广度优先遍历" class="headerlink" title="2、广度优先遍历"></a>2、广度优先遍历</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">;<span class="comment">//层序遍历</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">solution</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">invertTree</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">            queue&lt;TreeNode*&gt; que;</span><br><span class="line">            <span class="keyword">if</span>(root != <span class="literal">NULL</span>)</span><br><span class="line">                que.<span class="built_in">push</span>(root);</span><br><span class="line">            <span class="keyword">while</span>(!que.<span class="built_in">empty</span>())&#123;</span><br><span class="line">                <span class="type">int</span> size = que.<span class="built_in">size</span>();</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; size;i ++)&#123;</span><br><span class="line">                    TreeNode* node = que.<span class="built_in">front</span>();</span><br><span class="line">                    que.<span class="built_in">pop</span>();</span><br><span class="line">                    <span class="built_in">swap</span>(node -&gt; left,node -&gt; right);<span class="comment">//左右子树交换</span></span><br><span class="line">                    <span class="keyword">if</span>(node -&gt; left)</span><br><span class="line">                        que.<span class="built_in">push</span>(node -&gt; left);</span><br><span class="line">                    <span class="keyword">if</span>(node -&gt; right)</span><br><span class="line">                        que.<span class="built_in">push</span>(node -&gt; right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>针对二叉树的问题，解题之前要想清楚究竟选择哪种遍历方式</p><h3 id="七、对称二叉树"><a href="#七、对称二叉树" class="headerlink" title="七、对称二叉树"></a>七、对称二叉树</h3><p>给定一个二叉树，检查二叉树是否镜像对称</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//自己的第一遍思考</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">solution</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">Tree</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">            stack&lt;TreeNode*&gt; que;</span><br><span class="line">            vector&lt;<span class="type">int</span>&gt; vec;</span><br><span class="line">            <span class="type">int</span> flag = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(root != <span class="literal">NULL</span>)</span><br><span class="line">                que.<span class="built_in">push</span>(root);</span><br><span class="line">            <span class="keyword">while</span>(!que.<span class="built_in">empty</span>())&#123;</span><br><span class="line">                <span class="type">int</span> size = que.<span class="built_in">size</span>();</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; size;i ++)&#123;</span><br><span class="line">                    TreeNode* node = que.<span class="built_in">front</span>();</span><br><span class="line">                    que.<span class="built_in">pop</span>();</span><br><span class="line">                    vec.<span class="built_in">push_back</span>(node -&gt; val);</span><br><span class="line">                    <span class="keyword">if</span>(node -&gt; left)</span><br><span class="line">                        que.<span class="built_in">push</span>(node -&gt; left);</span><br><span class="line">                    <span class="keyword">if</span>(node -&gt; right)</span><br><span class="line">                        que.<span class="built_in">push</span>(node -&gt; right);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">for</span>(j = <span class="number">0</span>;j &lt; size;j ++)&#123;</span><br><span class="line">                    <span class="keyword">if</span>((vec[j] != vec[size - <span class="number">1</span> -j] || vec[j] == <span class="literal">NULL</span> || vec[size - <span class="number">1</span>-                         <span class="number">1</span> - j] == <span class="literal">NULL</span>)</span><br><span class="line">                       flag =<span class="number">1</span>;</span><br><span class="line">                       <span class="keyword">return</span> flag;       </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> flag;</span><br><span class="line">        &#125;  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>针对自己第一次实现的想法进行改进：首先判断二叉树是否对称，不需要加入根节点（遍历则需要加入），因为是否对称只和左右子树有关。同时鉴于对队列数据结构的不熟练，调用了vector数组来储存节点数值后在数组中进行比较（考虑麻烦了），直接对称的将左右子树的节点加入到队列中，两个两个一组弹出比较。还加了flag标记来输出bool数，直接true or false即可。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//迭代</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">solution</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isSymmetric</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(root == <span class="literal">NULL</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            queue&lt;TreeNode*&gt; que;</span><br><span class="line">            que.<span class="built_in">push</span>(root -&gt; left);<span class="comment">//加入左子树头结点</span></span><br><span class="line">            que.<span class="built_in">push</span>(root -&gt; right);<span class="comment">//加入右子树头结点</span></span><br><span class="line">            <span class="keyword">while</span>(!que.<span class="built_in">empty</span>())&#123;</span><br><span class="line">                TreeNode* leftNode = que.<span class="built_in">front</span>();</span><br><span class="line">                que.<span class="built_in">pop</span>();</span><br><span class="line">                TreeNode* rightNode = que.<span class="built_in">front</span>();</span><br><span class="line">                que.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="keyword">if</span>(!leftNode &amp;&amp; !leftNode)</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                </span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span>(!leftNode || !rightNode || (leftNode -&gt; val != rightNode -&gt; val))</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                </span><br><span class="line">                que.<span class="built_in">push</span>(leftNode -&gt; left);</span><br><span class="line">                que.<span class="built_in">push</span>(rightNode -&gt; right);</span><br><span class="line">                que.<span class="built_in">push</span>(leftNode -&gt; right);</span><br><span class="line">                que.<span class="built_in">push</span>(rightNode -&gt; left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>递归</p><p>1、确定递归参数和返回值</p><p>比较根节点的两个子树是否是互相翻转的，进而判断这个二叉树是否对称，比较的是左右两个子树，参数就是根节点的左子树头结点和右子树头结点。</p><p>返回值自然是bool类型。</p><p>2、确定终止条件</p><p>要比较两个节点的数值相不相等，首先要把两节点为空的情况搞清楚。</p><ul><li>左节点为空，右节点不为空</li><li>左节点不为空，右节点为空</li><li>左右节点都为空</li><li>左右节点都不为空但是值不相等   </li></ul><p>3、确定单层递归的逻辑</p><p>单层递归的逻辑就是两个节点都不为空且节点值相等的情况。</p><ul><li>比较外侧节点值是否相等：传入左节点的左孩子，右节点的右孩子</li><li>比较内侧节点值是否相等：传入左节点的右孩子，右节点的左孩子</li><li>如果左右都对称返回true，有一方不对称就返回false</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">solution</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">compare</span><span class="params">(TreeNode* left,TreeNode* right)</span></span>&#123;</span><br><span class="line">            <span class="comment">//首先排除空节点的情况</span></span><br><span class="line">            <span class="keyword">if</span>(!left &amp;&amp; right)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(left &amp;&amp; !right)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(!left &amp;&amp; !right)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="comment">//排除空节点后，两节点值不相等的情况</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>((left -&gt; val) != (right -&gt; val))</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//左子树：左，右子树：右</span></span><br><span class="line">            <span class="type">bool</span> outside = <span class="built_in">compare</span>(left -&gt; left,right -&gt; right);</span><br><span class="line">            <span class="comment">//左子树：右，右子树：左</span></span><br><span class="line">            <span class="type">bool</span> inside = <span class="built_in">compare</span>(left -&gt; right,right -&gt; left);</span><br><span class="line">            <span class="comment">//逻辑处理</span></span><br><span class="line">            <span class="type">bool</span> isSame = outside &amp;&amp; inside;</span><br><span class="line">            <span class="keyword">return</span> isSame;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isSymmetric</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(root == <span class="literal">NULL</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">compare</span>(root -&gt; left,root -&gt; right);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="八、二叉树的最大深度"><a href="#八、二叉树的最大深度" class="headerlink" title="八、二叉树的最大深度"></a>八、二叉树的最大深度</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//前序遍历</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">solution</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> result;<span class="comment">//用来存储最大深度</span></span><br><span class="line">        <span class="comment">//函数返回值为void，非int，与计算节点数不同，深度不具有累加性</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">getDepth</span><span class="params">(TreeNode* node,<span class="type">int</span> depth)</span></span>&#123;<span class="comment">//参数为当前节点，以及当前的深度</span></span><br><span class="line">            result = depth &gt; result ? depth : result;<span class="comment">//通过不断比较深度来更新深度的值</span></span><br><span class="line">            <span class="keyword">if</span>(!node-&gt;left &amp;&amp; !node-&gt;right)</span><br><span class="line">                <span class="keyword">return</span> ;</span><br><span class="line">            <span class="keyword">if</span>(node-&gt;left)&#123;<span class="comment">//左</span></span><br><span class="line">                depth ++;<span class="comment">//深度加一，因为向下了一层</span></span><br><span class="line">                <span class="built_in">getDepth</span>(node-&gt;left,depth);</span><br><span class="line">                depth --;<span class="comment">//回溯，因为右子树还未进行</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(node-&gt;right)&#123;<span class="comment">//同理，右</span></span><br><span class="line">                depth ++;</span><br><span class="line">                <span class="built_in">getDepth</span>(node-&gt;right,depth);</span><br><span class="line">                depth --;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">            result = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span>(root == <span class="literal">nullptr</span>)</span><br><span class="line">                <span class="keyword">return</span> result;</span><br><span class="line">            <span class="built_in">getDepth</span>(root,<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;；</span><br></pre></td></tr></table></figure><p>迭代法中层序遍历最为合适，因为遍历的层数即是二叉树的深度</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">solution</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">            queue&lt;TreeNode*&gt; que;</span><br><span class="line">            <span class="type">int</span> depth = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span>(root != <span class="literal">NULL</span>)</span><br><span class="line">                que.<span class="built_in">push</span>(root);</span><br><span class="line">            <span class="keyword">while</span>(!que.<span class="built_in">empty</span>())&#123;</span><br><span class="line">                <span class="type">int</span> size = que.<span class="built_in">size</span>();</span><br><span class="line">                depth ++;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; size;i ++)&#123;</span><br><span class="line">                    TreeNode* node = que.<span class="built_in">front</span>();</span><br><span class="line">                    que.<span class="built_in">pop</span>();</span><br><span class="line">                    <span class="keyword">if</span>(node -&gt; left)</span><br><span class="line">                        que.<span class="built_in">push</span>(node -&gt; left);</span><br><span class="line">                    <span class="keyword">if</span>(node -&gt; right)</span><br><span class="line">                     que.<span class="built_in">push</span>(node -&gt; right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> depth;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>n叉树的最大深度</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">solution</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">            queue&lt;TreeNode*&gt; que;</span><br><span class="line">            <span class="type">int</span> depth = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span>(root != <span class="literal">NULL</span>)</span><br><span class="line">                que.<span class="built_in">push</span>(root);</span><br><span class="line">            <span class="keyword">while</span>(!que.<span class="built_in">empty</span>())&#123;</span><br><span class="line">                <span class="type">int</span> size = que.<span class="built_in">front</span>();</span><br><span class="line">                depth ++;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; size;i ++)&#123;</span><br><span class="line">                    TreeNode* node = que.<span class="built_in">front</span>();</span><br><span class="line">                    que.<span class="built_in">pop</span>();</span><br><span class="line">                    <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>;j &lt; node -&gt; children.<span class="built_in">size</span>();j ++)&#123;</span><br><span class="line">                        <span class="keyword">if</span>(node -&gt; children[j])</span><br><span class="line">                            que.<span class="built_in">push</span>(node -&gt; children[j]);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> depth;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="九、二叉树的最小深度"><a href="#九、二叉树的最小深度" class="headerlink" title="九、二叉树的最小深度"></a>九、二叉树的最小深度</h3><p>最小深度是指根节点到最近叶子节点的最短路径上的节点个数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">solution</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minDepth</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">        queue&lt;TreeNode*&gt; que;</span><br><span class="line">            <span class="type">int</span> depth = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span>(root != <span class="literal">NULL</span>)</span><br><span class="line">                que.<span class="built_in">push</span>(root);</span><br><span class="line">            <span class="keyword">while</span>(!que.<span class="built_in">empty</span>())&#123;</span><br><span class="line">                <span class="type">int</span> size = que.<span class="built_in">size</span>();</span><br><span class="line">                depth ++;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; size;i ++)&#123;</span><br><span class="line">                    TreeNode* node = que.<span class="built_in">front</span>();</span><br><span class="line">                    que.<span class="built_in">pop</span>();</span><br><span class="line">                    <span class="keyword">if</span>((!node -&gt; left) &amp;&amp; (!node -&gt; right))<span class="comment">//左右节点都为空时到达最小深度</span></span><br><span class="line">                        <span class="keyword">return</span> depth;</span><br><span class="line">                    <span class="keyword">if</span>(node -&gt; left)</span><br><span class="line">                        que.<span class="built_in">push</span>(node -&gt; left);</span><br><span class="line">                    <span class="keyword">if</span>(node -&gt; right)</span><br><span class="line">                     que.<span class="built_in">push</span>(node -&gt; right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> depth;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="十、完全二叉树的节点个数"><a href="#十、完全二叉树的节点个数" class="headerlink" title="十、完全二叉树的节点个数"></a>十、完全二叉树的节点个数</h3><p>将完全二叉树当作普通二叉树看待，依旧使用普通二叉树的遍历方法来计算节点个数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//递归法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">solution</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getNodeNums</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(root == <span class="literal">nullptr</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            <span class="type">int</span> leftNodeNums = <span class="built_in">getNodeNums</span>(root -&gt; left);<span class="comment">//左</span></span><br><span class="line">            <span class="type">int</span> rightNodeNums = <span class="built_in">getNodeNums</span>(root -&gt; right);<span class="comment">//右</span></span><br><span class="line">            <span class="type">int</span> nodeNums = leftNodeNums + rightNodeNums + <span class="number">1</span>;<span class="comment">//中</span></span><br><span class="line">            <span class="keyword">return</span> nodeNums;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">countNodes</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">getNodeNums</span>(root);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//迭代法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">solution</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">countNodes</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">            queue&lt;TreeNode*&gt; que;</span><br><span class="line">            <span class="keyword">if</span>(root != <span class="literal">NULL</span>)</span><br><span class="line">                que.<span class="built_in">push</span>(root);</span><br><span class="line">            <span class="type">int</span> result = <span class="number">0</span>;<span class="comment">//记录节点个数</span></span><br><span class="line">            <span class="keyword">while</span>(!que.<span class="built_in">empty</span>())&#123;</span><br><span class="line">                <span class="type">int</span> size = que.<span class="built_in">size</span>();</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; size;i ++)&#123;</span><br><span class="line">                    TreeNode* node = que.<span class="built_in">front</span>();</span><br><span class="line">                    que.<span class="built_in">pop</span>();</span><br><span class="line">                    result ++;<span class="comment">//每遍历一个节点加一</span></span><br><span class="line">                    <span class="keyword">if</span>(node -&gt; left)</span><br><span class="line">                        que.<span class="built_in">push</span>(node -&gt; left);</span><br><span class="line">                    <span class="keyword">if</span>(node -&gt; right)</span><br><span class="line">                        que.<span class="built_in">push</span>(node -&gt; right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>然而，完全二叉树本省具有一些特性使得能够使用一些其它的方法来计算个数</p><p>在完全二叉树中，除了最底层的节点可能没有填满之外，其余每层节点数都达到最大值，并且最下面一层节点都集中在该层最左侧的若干区域，若最底层为第h层，则该层节点个数范围为1~2^(h-1)</p><p>完全二叉树只有两种情况，情况一：就是满二叉树，情况二：最后一层叶子节点没有满。</p><p>对于情况一，可以直接用 2^树深度 - 1 来计算，注意这里根节点深度为1。</p><p>对于情况二，分别递归左孩子，和右孩子，递归到某一深度一定会有左孩子或者右孩子为满二叉树，然后依然可以按照情况1来计算。</p><p>可以看出如果整个树不是满二叉树，就递归其左右孩子，直到遇到满二叉树为止，用公式计算这个子树（满二叉树）的节点数量。</p><p>这里关键在于如何去判断一个左子树或者右子树是不是满二叉树呢？</p><p>在完全二叉树中，如果递归向左遍历的深度等于递归向右遍历的深度，那说明就是满二叉树。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">solution</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">countNodes</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(root == <span class="literal">nullptr</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            TreeNode* left = root -&gt; left;</span><br><span class="line">            TreeNode* right = root -&gt; right;</span><br><span class="line">            <span class="type">int</span> leftDepth = <span class="number">0</span>;</span><br><span class="line">            <span class="type">int</span> rightDepth = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(left)&#123;</span><br><span class="line">                left = left -&gt; left;</span><br><span class="line">                leftDepth ++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span>(right)&#123;</span><br><span class="line">                right = right -&gt; right;</span><br><span class="line">                rightDepth ++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(leftDepth == rightDepth)</span><br><span class="line">                <span class="keyword">return</span> <span class="number">2</span>^(leftDepth - <span class="number">1</span>);</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">countNodes</span>(root -&gt; left) + <span class="built_in">countNodes</span>(root -&gt; right) + <span class="number">1</span>;</span><br><span class="line">                </span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="十一、平衡二叉树"><a href="#十一、平衡二叉树" class="headerlink" title="十一、平衡二叉树"></a>十一、平衡二叉树</h3><p>因为求深度可以从上到下去查 所以需要前序遍历（中左右），而高度只能从下到上去查，所以只能后序遍历（左右中）</p><p>一颗高度平衡的二叉树定义为：一个二叉树每个节点的左右两棵子树的高度差绝对值不超过1。</p><p>根据定义可知，如果以当前节点为传入节点的二叉树已经不是二叉树了，则该二叉树不是平衡二叉树</p><p>return -1来标记不符合平衡二叉树的规则。</p><p>递归思路：</p><p>1、明确递归函数的参数和返回值</p><p>参数：当前传入节点。 返回值：以当前传入节点为根节点的树的高度。</p><p>那么如何标记左右子树是否差值大于1呢？</p><p>如果当前传入节点为根节点的二叉树已经不是二叉平衡树了，还返回高度的话就没有意义了。</p><p>所以如果已经不是二叉平衡树了，可以返回-1 来标记已经不符合平衡树的规则了。</p><p>2、明确终止条件</p><p>递归的过程中依然是遇到空节点了为终止，返回0，表示当前节点为根节点的树高度为0</p><p>3、明确单层递归的逻辑</p><p>如何判断以当前传入节点为根节点的二叉树是否是平衡二叉树呢？当然是其左子树高度和其右子树高度的差值。</p><p>分别求出其左右子树的高度，然后如果差值小于等于1，则返回当前二叉树的高度，否则返回-1，表示已经不是二叉平衡树了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//递归</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">solution</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getHeight</span><span class="params">(TreeNode* node)</span></span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(node == <span class="literal">nullptr</span>)<span class="comment">//如果该节点是空指针，则高度为0</span></span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            <span class="comment">//判断左右子树是否是平衡二叉树，有一个不是则非平衡二叉树</span></span><br><span class="line">            <span class="type">int</span> leftHeight = <span class="built_in">getHeight</span>(node-&gt;left);</span><br><span class="line">            <span class="keyword">if</span>(leftHeight == <span class="number">-1</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">            <span class="type">int</span> rightHeight = <span class="built_in">getHeight</span>(node-&gt;right);</span><br><span class="line">            <span class="keyword">if</span>(LeftHeight == <span class="number">-1</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">abs</span>(leftHeight - rightHeight) &gt; <span class="number">1</span>)&#123;<span class="comment">//左右子树高度差不超过1</span></span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//取两树高度最大者在加上根节点的高度为整颗平衡二叉树的高度</span></span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">max</span>(leftHeight,rightHeight) + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isBalance</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">getHeight</span>(root) == <span class="number">-1</span> ? <span class="literal">false</span> : <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//迭代</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">solution</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="comment">//node节点的最大深度就是node的高度</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getDepth</span><span class="params">(TreeNode* node)</span></span>&#123;</span><br><span class="line">            stack&lt;TreeNode*&gt; st;</span><br><span class="line">            <span class="keyword">if</span>(node == <span class="literal">nullptr</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            <span class="type">int</span> depth = <span class="number">0</span>;<span class="comment">//记录深度</span></span><br><span class="line">            <span class="type">int</span> result = <span class="number">0</span>;<span class="comment">//更新最大深度值</span></span><br><span class="line">            st.<span class="built_in">push</span>(node);</span><br><span class="line">            <span class="keyword">while</span>(!st.<span class="built_in">empty</span>())&#123;</span><br><span class="line">                TreeNode* cur = st.<span class="built_in">top</span>();</span><br><span class="line">                <span class="keyword">if</span>(node != <span class="literal">NULL</span>)&#123;</span><br><span class="line">                    st.<span class="built_in">pop</span>();</span><br><span class="line">                    st.<span class="built_in">push</span>(cur);</span><br><span class="line">                    st.<span class="built_in">push</span>(<span class="literal">NULL</span>);</span><br><span class="line">                    depth ++;</span><br><span class="line">                    <span class="keyword">if</span>(cur-&gt;right)</span><br><span class="line">                        st.<span class="built_in">push</span>(cur-&gt;right);</span><br><span class="line">                    <span class="keyword">if</span>(cur-&gt;left)</span><br><span class="line">                        st.<span class="built_in">push</span>(cur-&gt;left);</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    st.<span class="built_in">pop</span>();</span><br><span class="line">                    node = st.<span class="built_in">top</span>();</span><br><span class="line">                    st.<span class="built_in">pop</span>();</span><br><span class="line">                    depth --;</span><br><span class="line">                &#125;</span><br><span class="line">                result = result &gt; depth ? result : depth;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isBalance</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">            stack&lt;TreeNode*&gt; st;</span><br><span class="line">            <span class="keyword">if</span>(root == <span class="literal">NULL</span>)</span><br><span class="line">               <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            st.<span class="built_in">push</span>(root);</span><br><span class="line">            <span class="keyword">while</span>(!st.<span class="built_in">empty</span>())&#123;</span><br><span class="line">                TreeNode* node = st.<span class="built_in">top</span>();</span><br><span class="line">                st.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">abs</span>(<span class="built_in">getDepth</span>(node-&gt;left),<span class="built_in">getDepth</span>(node-&gt;right))&gt;<span class="number">1</span>)</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">if</span>(node-&gt;right)</span><br><span class="line">                    st.<span class="built_in">push</span>(node-&gt;right);</span><br><span class="line">                <span class="keyword">if</span>(node-&gt;left)</span><br><span class="line">                    st.<span class="built_in">push</span>(node-&gt;left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>求深度适合前序遍历，求高度适合后序遍历</p><h3 id="十二、二叉树的所有路径"><a href="#十二、二叉树的所有路径" class="headerlink" title="十二、二叉树的所有路径"></a>十二、二叉树的所有路径</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">solution</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">traversal</span><span class="params">(TreeNode* node,vector&lt;<span class="type">int</span>&gt; path,vector&lt;string&gt; result)</span></span>&#123;</span><br><span class="line">            path.<span class="built_in">push_back</span>(node-&gt;val);</span><br><span class="line">            <span class="keyword">if</span>(node-&gt;left == <span class="literal">NULL</span> &amp;&amp; node-&gt;right == <span class="literal">NULL</span>)&#123;</span><br><span class="line">                string sPath;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; path.<span class="built_in">size</span>() - <span class="number">1</span>;i++)&#123;</span><br><span class="line">                    sPath += <span class="built_in">to_string</span>(path[i]);</span><br><span class="line">                    sPath += <span class="string">&quot;-&gt;&quot;</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                sPath += <span class="built_in">to_string</span>(path[path.<span class="built_in">size</span>() - <span class="number">1</span>]);</span><br><span class="line">                result.<span class="built_in">push_back</span>(sPath);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="keyword">if</span>(node-&gt;left)&#123;</span><br><span class="line">                <span class="built_in">traversal</span>(node-&gt;left,path,result);</span><br><span class="line">                path.<span class="built_in">pop_back</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(node-&gt;right)&#123;</span><br><span class="line">                <span class="built_in">traversal</span>(node-&gt;right,path,result);</span><br><span class="line">                path.<span class="built_in">pop_back</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">binaryTreePaths</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">            vector&lt;<span class="type">int</span>&gt; path;</span><br><span class="line">            vector&lt;string&gt; result;</span><br><span class="line">            <span class="keyword">if</span>(root == <span class="literal">NULL</span>)</span><br><span class="line">                <span class="keyword">return</span> result;</span><br><span class="line">            <span class="built_in">traversal</span>(root,path,result);</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="十三、左叶子之和"><a href="#十三、左叶子之和" class="headerlink" title="十三、左叶子之和"></a>十三、左叶子之和</h3><p>1、确定递归函数的参数和返回值</p><p>要判断左节点值之和，首先要传入根节点，返回值则为数值之和</p><p>2、确定终止条件</p><p>如果遍历到空节点，左叶子值为0</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(root == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure><p>注意，只有当前节点遍历的是父节点，才能判断其子节点是不是左叶子。所以如果当前遍历的节点是叶子节点，那其左叶子也必定为0</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(root-&gt;left == <span class="literal">NULL</span> &amp;&amp; root-&gt;right == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure><p>3、确定单层递归的逻辑</p><p>遇到左叶子节点时，记录数值，然后通过递归求取左子树左叶子之和和右子树左叶子之和。相当于整个树的左叶子之和</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//递归法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">solution</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">sumOfLeftLeaves</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(root == <span class="literal">NULL</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span>(root-&gt;left == <span class="literal">NULL</span> &amp;&amp; root-&gt;right == <span class="literal">NULL</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="type">int</span> LeftValue = <span class="built_in">sumOfLeftLeaves</span>(root-&gt;left);<span class="comment">//左</span></span><br><span class="line">            <span class="comment">//当左子树只是一个左叶子节点的时候</span></span><br><span class="line">            <span class="keyword">if</span>(root-&gt;left &amp;&amp; !root-&gt;left-&gt;left &amp;&amp; !root-&gt;left-&gt;right)</span><br><span class="line">                leftValue = root-&gt;left-&gt;val;</span><br><span class="line">            </span><br><span class="line">            <span class="type">int</span> rightValue = <span class="built_in">sumOfLeftLeaves</span>(root-&gt;right);<span class="comment">//右</span></span><br><span class="line">            <span class="type">int</span> sum = leftValue + rightValue;<span class="comment">//中</span></span><br><span class="line">            <span class="keyword">return</span> sum;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//迭代法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">solution</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">sumOfLeftLeaves</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(root == <span class="literal">NULL</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            stack&lt;TreeNode*&gt; st;</span><br><span class="line">            st.<span class="built_in">push</span>(root);</span><br><span class="line">            <span class="type">int</span> result = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(!st.<span class="built_in">empty</span>())&#123;</span><br><span class="line">                TreeNode* node = st.<span class="built_in">top</span>();</span><br><span class="line">                st.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="keyword">if</span>(node-&gt;left &amp;&amp; !node-&gt;left-&gt;left &amp;&amp; !node-&gt;left-&gt;right)</span><br><span class="line">                    result += node-&gt;left-&gt;val;</span><br><span class="line">                <span class="keyword">if</span>(node-&gt;right)</span><br><span class="line">                   st.<span class="built_in">push</span>(node-&gt;right);</span><br><span class="line">                <span class="keyword">if</span>(node-&gt;left)</span><br><span class="line">                   st.<span class="built_in">push</span>(node-&gt;left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="十四、找树左下角的值"><a href="#十四、找树左下角的值" class="headerlink" title="十四、找树左下角的值"></a>十四、找树左下角的值</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//层序遍历</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">solution</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findBottomLeftValue</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">            queue&lt;TreeNode*&gt; que;</span><br><span class="line">            <span class="keyword">if</span>(root != <span class="literal">NULL</span>)</span><br><span class="line">                que.<span class="built_in">push</span>(root);</span><br><span class="line">            <span class="type">int</span> result = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(!que.<span class="built_in">empty</span>())&#123;</span><br><span class="line">                <span class="type">int</span> size = que.<span class="built_in">size</span>();</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; size;i ++)&#123;</span><br><span class="line">                    TreeNode* node = que.<span class="built_in">front</span>();</span><br><span class="line">                    <span class="keyword">if</span>(i == <span class="number">0</span>)</span><br><span class="line">                        result = node-&gt;val;<span class="comment">//每层取第一个节点的值</span></span><br><span class="line">                    que.<span class="built_in">pop</span>();</span><br><span class="line">                    <span class="keyword">if</span>(node-&gt;left)</span><br><span class="line">                        que.<span class="built_in">push</span>(node-&gt;left);</span><br><span class="line">                    <span class="keyword">if</span>(node-&gt;right)</span><br><span class="line">                        que.<span class="built_in">push</span>(node-&gt;right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> result;<span class="comment">//遍历完所有层后result里的值则为树左下角的值</span></span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//递归法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">solution</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//定义全局变量</span></span><br><span class="line">    <span class="type">int</span> maxDepth = INT_MIN;<span class="comment">//记录最大深度</span></span><br><span class="line">    <span class="type">int</span> result;<span class="comment">//记录树左下角的值</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">traversal</span><span class="params">(TreeNode* node,<span class="type">int</span> depth)</span></span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(!node-&gt;left &amp;&amp; !node-&gt;left)&#123;</span><br><span class="line">                <span class="keyword">if</span>(depth &gt; maxDepth)&#123;</span><br><span class="line">                    maxDepth = depth;</span><br><span class="line">                    result = node-&gt;val;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> ;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(node-&gt;left)&#123;</span><br><span class="line">                <span class="comment">//traversal(node-&gt;left,depth + 1);</span></span><br><span class="line">                depth ++;</span><br><span class="line">                <span class="built_in">traversal</span>(node-&gt;left,depth);</span><br><span class="line">                depth --;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(node-&gt;right)&#123;</span><br><span class="line">                <span class="comment">//traversal(node-&gt;right,depth + 1);</span></span><br><span class="line">                depth ++;</span><br><span class="line">                <span class="built_in">traversal</span>(node-&gt;right,depth);</span><br><span class="line">                depth --;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findBottomLeftValue</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">            <span class="built_in">traversal</span>(root,<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>总结：</p><p>1、递归求深度的写法，在<strong>平衡树二叉树</strong>中详细分析了深度应该怎么求，高度应该怎么求</p><p>2、递归中隐藏了回溯，在<strong>二叉树的所有路径</strong> 中讲解了究竟哪里使用了回溯，哪里隐藏了回溯</p><p>3、层次遍历，在<strong>层序遍历</strong>深度讲解了二叉树层序遍历。</p><h3 id="十五、路径总和I"><a href="#十五、路径总和I" class="headerlink" title="十五、路径总和I"></a>十五、路径总和I</h3><p>给定一个二叉树和目标和，判断该树是否存在根节点到叶子节点的路径，这条路径上的所有节点值相加等于目标和</p><p>递归：</p><p>1、确定函数返回值和参数</p><p>需要一个指针遍历二叉树，同时需要int参数来记录目标和，使用递减的方式，当某条路径上的result递减至0且到叶子节点时，说明该二叉树存在所有节点值相加等于目标和的路径</p><p>2、确定终止条件</p><p> 当和递减至0且遍历到叶子节点时，存在</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(result == <span class="number">0</span> &amp;&amp; !cur-&gt;left &amp;&amp; !cur-&gt;right) <span class="keyword">return</span> <span class="literal">true</span>;</span><br></pre></td></tr></table></figure><p>当遇到叶子节点未满足条件时，不存在</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(!cur-&gt;left &amp;&amp; !cur-&gt;right) <span class="keyword">return</span> <span class="literal">false</span>;</span><br></pre></td></tr></table></figure><p>3、确定单层递归的逻辑</p><p>先向左继续判断，不满足再向右继续判断，都不满足则不存在该路径</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(cur-&gt;left)&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">traversal</span>(cur-&gt;left,result - cur-&gt;left-&gt;val))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(cur-&gt;right)&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">traversal</span>(cur-&gt;right,result - cur-&gt;right-&gt;val))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//递归法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">solution</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">traversal</span><span class="params">(TreeNode* cur,<span class="type">int</span> result)</span></span>&#123;<span class="comment">//记录当前节点和目标和</span></span><br><span class="line">            <span class="comment">//当和递减至0且遍历到叶子节点时，存在</span></span><br><span class="line">            <span class="keyword">if</span>(result == <span class="number">0</span> &amp;&amp; !cur-&gt;left &amp;&amp; !cur-&gt;right)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="comment">//当遇到叶子节点未满足条件时，不存在</span></span><br><span class="line">            <span class="keyword">if</span>(!cur-&gt;left &amp;&amp; !cur-&gt;right)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(cur-&gt;left)&#123;<span class="comment">//左</span></span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">traversal</span>(cur-&gt;left,result - cur-&gt;left-&gt;val))<span class="comment">//包含回溯的逻辑</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(cur-&gt;right)&#123;<span class="comment">//右</span></span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">traversal</span>(cur-&gt;right,result - cur-&gt;right-&gt;val))<span class="comment">//包含回溯的逻辑</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="comment">/*将回溯过程体现出来代码可改为：</span></span><br><span class="line"><span class="comment">            if(cur-&gt;left)&#123;</span></span><br><span class="line"><span class="comment">            result -= cur-&gt;left-&gt;val;</span></span><br><span class="line"><span class="comment">            if(traversal(cur-&gt;left,result))</span></span><br><span class="line"><span class="comment">            return true;</span></span><br><span class="line"><span class="comment">            result += cur-&gt;left-&gt;val;</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">            if(cur-&gt;right)&#123;</span></span><br><span class="line"><span class="comment">            result -= cur-&gt;right-&gt;val;</span></span><br><span class="line"><span class="comment">            if(traversal(cur-&gt;right,result))</span></span><br><span class="line"><span class="comment">            return true;</span></span><br><span class="line"><span class="comment">            result += cur-&gt;right-&gt;val;</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">hasPathSum</span><span class="params">(TreeNode* root,<span class="type">int</span> sum)</span></span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(root == <span class="literal">NULL</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">traversal</span>(root,sum - root-&gt;val);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>递归过程隐藏回溯，如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">traversal</span>(cur-&gt;left,result - cur-&gt;left-&gt;val);</span><br></pre></td></tr></table></figure><p>把result - cur-&gt;left-&gt;val直接作为参数传进函数，函数结束，result的数值并没有改变</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//迭代法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">solution</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">hasPathSum</span><span class="params">(TreeNode* root,<span class="type">int</span> sum)</span></span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(root == <span class="literal">nullptr</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="comment">//此时栈里放的是pair&lt;节点指针，路径数值&gt;</span></span><br><span class="line">            stack&lt;pair&lt;TreeNode*,<span class="type">int</span>&gt;&gt; st;</span><br><span class="line">            st.<span class="built_in">push</span>(<span class="built_in">pair</span>&lt;TreeNode*,<span class="type">int</span>&gt;(root,root-&gt;val));</span><br><span class="line">            <span class="keyword">while</span>(!st.<span class="built_in">empty</span>())&#123;</span><br><span class="line">                pair&lt;TreeNode*,<span class="type">int</span>&gt; node = st.<span class="built_in">top</span>();</span><br><span class="line">                st.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="comment">//如果该节点是叶子节点，同时该路径数值等于sum，返回true</span></span><br><span class="line">                <span class="keyword">if</span>(!node.first-&gt;left &amp;&amp; !node.first-&gt;right &amp;&amp; sum == node.second)</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                <span class="comment">//右节点，压入节点的同时，记录路径数值</span></span><br><span class="line">                <span class="keyword">if</span>(node.first-&gt;right)</span><br><span class="line">                    st.<span class="built_in">push</span>(<span class="built_in">pair</span>&lt;TreeNode*,<span class="type">int</span>&gt;(node.first-&gt;right,node.second +                           node.first-&gt;right-&gt;val));</span><br><span class="line">                <span class="comment">//左节点，压入节点的同时，记录路径数值</span></span><br><span class="line">                <span class="keyword">if</span>(node.first-&gt;left)</span><br><span class="line">                    st.<span class="built_in">push</span>(<span class="built_in">pair</span>&lt;TreeNode*,<span class="type">int</span>&gt;(node.first-&gt;left,node.second +                           node.first-&gt;left-&gt;val));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="十六、路径总和II"><a href="#十六、路径总和II" class="headerlink" title="十六、路径总和II"></a>十六、路径总和II</h3><p>给定一个二叉树和一个目标和，找到所有从根节点到叶子节点路径总和等于目标和的路径</p><p>递归：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">solution</span>&#123;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; result;<span class="comment">//记录所有和为sum的路径</span></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; path;<span class="comment">//记录单条遍历的路径</span></span><br><span class="line">        <span class="comment">//递归函数不需要返回值，因为要遍历整棵树</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">traversal</span><span class="params">(TreeNode* cur,<span class="type">int</span> count)</span></span>&#123;</span><br><span class="line">            <span class="comment">//遇到叶子节点且找到和为sum的路径</span></span><br><span class="line">            <span class="keyword">if</span>(!cur-&gt;left &amp;&amp; !cur-&gt;right &amp;&amp; count == <span class="number">0</span>)&#123;</span><br><span class="line">                result.<span class="built_in">push_back</span>(path);</span><br><span class="line">                <span class="keyword">return</span> ;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(!cur-&gt;left &amp;&amp; !cur-&gt;right)</span><br><span class="line">                <span class="keyword">return</span> ;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(cur-&gt;left)&#123;<span class="comment">//左</span></span><br><span class="line">                path.<span class="built_in">push_back</span>(cur-&gt;left-&gt;val);</span><br><span class="line">                <span class="built_in">traversal</span>(cur-&gt;left,count - cur-&gt;left-&gt;val);</span><br><span class="line">                path.<span class="built_in">pop_back</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(cur-&gt;right)&#123;<span class="comment">//右</span></span><br><span class="line">                path.<span class="built_in">push_back</span>(cur-&gt;right-&gt;val);</span><br><span class="line">                <span class="built_in">traversal</span>(cur-&gt;right,count - cur-&gt;right-&gt;val);</span><br><span class="line">                path.<span class="built_in">pop_back</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">/*体现回溯的过程</span></span><br><span class="line"><span class="comment">            if(cur-&gt;left)&#123;</span></span><br><span class="line"><span class="comment">            path.push_back(cur-&gt;left-&gt;val);</span></span><br><span class="line"><span class="comment">            count -= cur-&gt;left-&gt;val;</span></span><br><span class="line"><span class="comment">            traversal(cur-&gt;left,count);//递归</span></span><br><span class="line"><span class="comment">            count += cur-&gt;left-&gt;val;//回溯</span></span><br><span class="line"><span class="comment">            path.pop_back();//回溯</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">            if(cur-&gt;right)&#123;</span></span><br><span class="line"><span class="comment">            path.push_back(cur-&gt;left-&gt;val);</span></span><br><span class="line"><span class="comment">            count -= cur-&gt;right-&gt;val;</span></span><br><span class="line"><span class="comment">            traversal(cur-&gt;right,count);//递归</span></span><br><span class="line"><span class="comment">            count += cur-&gt;right-&gt;val;//回溯</span></span><br><span class="line"><span class="comment">            path.pop_back();//回溯</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">findPathSum</span>(TreeNode* root,<span class="type">int</span> sum)&#123;</span><br><span class="line">            result.<span class="built_in">clear</span>();</span><br><span class="line">            path.<span class="built_in">clear</span>();</span><br><span class="line">            <span class="keyword">if</span>(root == <span class="literal">NULL</span>)</span><br><span class="line">                <span class="keyword">return</span> result;</span><br><span class="line">            path.<span class="built_in">push_back</span>(root-&gt;val);</span><br><span class="line">          <span class="built_in">traversal</span>(root,sum - root-&gt;val);</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="十七、从中序与后序遍历序列构造二叉树"><a href="#十七、从中序与后序遍历序列构造二叉树" class="headerlink" title="十七、从中序与后序遍历序列构造二叉树"></a>十七、从中序与后序遍历序列构造二叉树</h3><p>根据一棵树的中序和后序遍历构造二叉树</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">solution</span>&#123;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">traversal</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; inorder,vector&lt;<span class="type">int</span>&gt;&amp; postorder)</span></span>&#123;</span><br><span class="line">            <span class="comment">//第一步</span></span><br><span class="line">            <span class="keyword">if</span>(postorder.<span class="built_in">size</span>() == <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">            <span class="comment">//后序遍历数组的最后一个元素，就是当前的中间节点</span></span><br><span class="line">            <span class="type">int</span> rootValue = postorder[postorder.<span class="built_in">size</span>() - <span class="number">1</span>];</span><br><span class="line">            TreeNode* root = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(rootValue);</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(postorder.<span class="built_in">size</span>() == <span class="number">1</span>)</span><br><span class="line">                <span class="keyword">return</span> root;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> delimiterIndex = <span class="number">0</span>;delimiter &lt; inorder.<span class="built_in">size</span>();delimiterIndex ++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(inorder[delimiterIndex] == rootValue)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">leftInorder</span><span class="params">(inorder.begin(),inorder.begin()+delimiterIndex)</span></span>;</span><br><span class="line">            <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">rightInorder</span><span class="params">(inorder.begin()+delimiterIndex+<span class="number">1</span>,inorder.end())</span></span>;</span><br><span class="line">            </span><br><span class="line">            postorder.<span class="built_in">resize</span>(postorder.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">            </span><br><span class="line">            <span class="function">vector&lt;<span class="type">int</span>&gt;                                                                           <span class="title">leftPostorder</span><span class="params">(postorder.begin(),postorder.begin()+leftInorder.size())</span></span>;</span><br><span class="line">            <span class="function">vector&lt;<span class="type">int</span>&gt;</span></span><br><span class="line"><span class="function">            <span class="title">rightPostorder</span><span class="params">(postorder.begin()+leftInorder.size(),postorder.end())</span></span>;</span><br><span class="line">            </span><br><span class="line">            root-&gt;left = <span class="built_in">traversal</span>(leftInorder,leftPostorder);</span><br><span class="line">            root-&gt;right = <span class="built_in">traversal</span>(rightInorder,rightPostorder);</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">bulidTree</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; inorder,vector&lt;<span class="type">int</span>&gt;&amp; postorder)</span></span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(inorder == <span class="literal">NULL</span> || postorder == <span class="literal">NULL</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">traversal</span>(inorder,postorder);</span><br><span class="line">        &#125;</span><br><span class="line">                        </span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="十八、最大二叉树"><a href="#十八、最大二叉树" class="headerlink" title="十八、最大二叉树"></a>十八、最大二叉树</h3><p>给定一个不含重复元素的整数数组。最大二叉树定义如下：</p><p>1、二叉树的根是数组中的最大元素</p><p>2、左子树是通过数组中的最大值左边部分构造出的最大二叉树</p><p>3、右子树是通过数组中的最大值左边部分构造出的最大二叉树</p><p>给定的数组大小在[1,1000]之间</p><p>1、确定递归函数参数和返回值</p><p>参数传入的是存放元素的数组，返回该数组构造的二叉树的头节点，返回类型是指向节点的指针</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">TreeNode* <span class="title">constructMaxBinaryTree</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span></span></span><br></pre></td></tr></table></figure><p>2、确定终止条件</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">TreeNode* node = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span>(nums.<span class="built_in">size</span>() == <span class="number">1</span>)&#123;</span><br><span class="line">    node-&gt;val = nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3、确定单层递归逻辑</p><p>分三步：</p><p>一、找到数组中最大的值与其对应的下标，最大的值构造根节点，下标用来下一步分割数组</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> maxValue = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> maxValueIndex = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; nums.<span class="built_in">size</span>();i ++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(nums[i] &gt; maxValue)&#123;</span><br><span class="line">        maxValue = nums[i];</span><br><span class="line">        maxValueIndex = i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">Treenode* node = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(<span class="number">0</span>);</span><br><span class="line">node-&gt;val = maxValue;</span><br></pre></td></tr></table></figure><p>二、最大值所在下标左区间 构造左子树</p><p>需要判断maxValueIndex&gt;0,因为至少保证左区间至少有一个数值</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(maxValueIndex &gt; <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">leftTree</span><span class="params">(nums.begin(),nums.begin()+maxValueIndex)</span></span>;</span><br><span class="line">    node-&gt;left = <span class="built_in">constructMaxBinaryTree</span>(leftTree);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>三、最大值所在下标右区间 构造右子树</p><p>maxValue&lt;(nums.size()-1),保证右区间至少有一个数值</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(maxValueIndex &lt; (nums.<span class="built_in">size</span>() - <span class="number">1</span>))&#123;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">rightTree</span><span class="params">(nums.begin()+maxValueIndex+<span class="number">1</span>,nums.end())</span></span>;</span><br><span class="line">    node-&gt;right = <span class="built_in">constructMaxBinaryTree</span>(rightTree);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">solution</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">constructMaxBinaryTree</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span></span>&#123;</span><br><span class="line">            TreeNode* node = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(<span class="number">0</span>);<span class="comment">//构造中节点</span></span><br><span class="line">            <span class="comment">//当数组只剩下一个元素，即叶子节点</span></span><br><span class="line">            <span class="keyword">if</span>(nums.<span class="built_in">size</span>() == <span class="number">1</span>)&#123;</span><br><span class="line">                node-&gt;val = nums[<span class="number">0</span>];</span><br><span class="line">                <span class="keyword">return</span> node;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//找到数组中的最大值与其下标</span></span><br><span class="line">            <span class="type">int</span> maxValue = <span class="number">0</span>;</span><br><span class="line">            <span class="type">int</span> maxValueIndex = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; nums.<span class="built_in">size</span>();i ++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[i] &gt; maxValue)&#123;</span><br><span class="line">                    maxValue = nums[i];</span><br><span class="line">                    maxValueIndex = i;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            node-&gt;val = maxValue;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//确保左右区间至少有一个元素</span></span><br><span class="line">            <span class="keyword">if</span>(maxValueIndex &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">left</span><span class="params">(nums.begin(),nums.begin()+maxValueIndex)</span></span>;</span><br><span class="line">                node-&gt;left = <span class="built_in">constructMaxBinaryTree</span>(left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(maxValueIndex &lt; nums.<span class="built_in">size</span>() - <span class="number">1</span>)&#123;</span><br><span class="line">                <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">right</span><span class="params">(nums.begin()+maxValueIndex+<span class="number">1</span>,nums.end())</span></span>;</span><br><span class="line">                node-&gt;right = <span class="built_in">constructMaxBinaryTree</span>(right);</span><br><span class="line">            &#125;   </span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>以上代码较为冗余，效率不高，每次分割数组后都要新定义vector，但是逻辑描述较为清晰</p><p>优化版：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">solution</span>&#123;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">//在左闭右开区间[left,rihgt)，构造二叉树</span></span><br><span class="line">    <span class="function">TreeNode* <span class="title">traversal</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums,<span class="type">int</span> left,<span class="type">int</span> right)</span></span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(left &gt;= right)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">            <span class="comment">//分割点下标：maxValueIndex</span></span><br><span class="line">            <span class="type">int</span> maxValueIndex = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; right;i ++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[i] &gt; nums[maxValueIndex])</span><br><span class="line">                    maxValueIndex = i;</span><br><span class="line">            &#125;</span><br><span class="line">            TreeNode* node = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(nums[maxValueIndex]);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//左闭右开[left,maxValueIndex)</span></span><br><span class="line">            node-&gt;left = <span class="built_in">traversal</span>(nums,left,maxValueIndex);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//左闭右开[maxValueIndex+1,right)</span></span><br><span class="line">            node-&gt;right = <span class="built_in">traversal</span>(nums,maxValueIndex+<span class="number">1</span>,right);</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">constructMaxBinaryTree</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span></span>&#123;</span><br><span class="line">            <span class="comment">//初始左闭右开区间[0,nums.size())</span></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">traversal</span>(nums,<span class="number">0</span>,nums.<span class="built_in">size</span>());</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
  
  
    
    
    <entry>
      <title>关于</title>
      <link href="/about/index.html"/>
      <url>/about/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/css/custom.css"/>
      <url>/css/custom.css</url>
      
        <content type="html"><![CDATA[/* 鼠标样式 */#cursor {    position: fixed;    width: 16px;    height: 16px;    /* 这里改变跟随的底色 */    background: rgb(57, 197, 187);    border-radius: 8px;    opacity: 0.25;    z-index: 10086;    pointer-events: none;    transition: 0.2s ease-in-out;    transition-property: background, opacity, transform;  }    #cursor.hidden {    opacity: 0;  }    #cursor.hover {    opacity: 0.1;    transform: scale(2.5);    -webkit-transform: scale(2.5);    -moz-transform: scale(2.5);    -ms-transform: scale(2.5);    -o-transform: scale(2.5);  }    #cursor.active {    opacity: 0.5;    transform: scale(0.5);    -webkit-transform: scale(0.5);    -moz-transform: scale(0.5);    -ms-transform: scale(0.5);    -o-transform: scale(0.5);  }  :root {    --trans-light: rgba(255, 255, 255, 0.88);    --trans-dark: rgba(25, 25, 25, 0.88);    --border-style: 1px solid rgb(169, 169, 169);    /*--backdrop-filter: blur(5px) saturate(150%);*/  }    /* 首页文章卡片 */  #recent-posts > .recent-post-item {    background: var(--trans-light);    backdrop-filter: var(--backdrop-filter);    border-radius: 25px;    border: var(--border-style);  }    /* 首页侧栏卡片 */  #aside-content .card-widget {    background: var(--trans-light);    backdrop-filter: var(--backdrop-filter);    border-radius: 18px;    border: var(--border-style);  }    /* 文章页、归档页、普通页面 */  div#post,  div#page,  div#archive {    background: var(--trans-light);    backdrop-filter: var(--backdrop-filter);    border: var(--border-style);    border-radius: 20px;  }    /* 导航栏 */  #page-header.nav-fixed #nav {    background: rgba(255, 255, 255, 0.75);    backdrop-filter: var(--backdrop-filter);  }    [data-theme="dark"] #page-header.nav-fixed #nav {    background: rgba(0, 0, 0, 0.7) !important;  }    /* 夜间模式遮罩 */  [data-theme="dark"] #recent-posts > .recent-post-item,  [data-theme="dark"] #aside-content .card-widget,  [data-theme="dark"] div#post,  [data-theme="dark"] div#archive,  [data-theme="dark"] div#page {    background: var(--trans-dark);  }      /* 夜间模式页脚页头遮罩透明 */  [data-theme="dark"] #footer::before {    background: transparent !important;  }  [data-theme="dark"] #page-header::before {    background: transparent !important;  }    /* 阅读模式 */  .read-mode #aside-content .card-widget {    background: rgba(158, 204, 171, 0.5) !important;  }  .read-mode div#post {    background: rgba(158, 204, 171, 0.5) !important;  }    /* 夜间模式下的阅读模式 */  [data-theme="dark"] .read-mode #aside-content .card-widget {    background: rgba(25, 25, 25, 0.9) !important;    color: #ffffff;  }  [data-theme="dark"] .read-mode div#post {    background: rgba(25, 25, 25, 0.9) !important;    color: #ffffff;  }  /* 侧边栏个人信息卡片动态渐变色 */#aside-content > .card-widget.card-info {  background: linear-gradient(    -45deg,    #e8d8b9,    #eccec5,    #a3e9eb,    #bdbdf0,    #eec1ea  );  box-shadow: 0 0 5px rgb(66, 68, 68);  position: relative;  background-size: 400% 400%;  -webkit-animation: Gradient 10s ease infinite;  -moz-animation: Gradient 10s ease infinite;  animation: Gradient 10s ease infinite !important;}@-webkit-keyframes Gradient {  0% {    background-position: 0% 50%;  }  50% {    background-position: 100% 50%;  }  100% {    background-position: 0% 50%;  }}@-moz-keyframes Gradient {  0% {    background-position: 0% 50%;  }  50% {    background-position: 100% 50%;  }  100% {    background-position: 0% 50%;  }}@keyframes Gradient {  0% {    background-position: 0% 50%;  }  50% {    background-position: 100% 50%;  }  100% {    background-position: 0% 50%;  }}/* 黑夜模式适配 */[data-theme="dark"] #aside-content > .card-widget.card-info {  background: #191919ee;}/* 个人信息Follow me按钮 */#aside-content > .card-widget.card-info > #card-info-btn {  background-color: #3eb8be;  border-radius: 8px;}/* 页脚与头图透明 */#footer {  background: transparent !important;}#page-header {  background: transparent !important;}/* 白天模式遮罩透明 */#footer::before {  background: transparent !important;}#page-header::before {  background: transparent !important;}/* 夜间模式遮罩透明 */[data-theme="dark"] #footer::before {  background: transparent !important;}[data-theme="dark"] #page-header::before {  background: transparent !important;}/* 一级菜单居中 */#nav .menus_items {  position: absolute !important;  width: fit-content !important;  left: 50% !important;  transform: translateX(-50%) !important;}/* 子菜单横向展示 */#nav .menus_items .menus_item:hover .menus_item_child {  display: flex !important;}/* 这里的2是代表导航栏的第2个元素，即有子菜单的元素，可以按自己需求修改 */.menus_items .menus_item:nth-child(5) .menus_item_child {  left: -38px;}/* 日间模式不生效 */[data-theme="light"] #site-name,[data-theme="light"] #site-title,[data-theme="light"] #site-subtitle,[data-theme="light"] #post-info {  animation: none;}/* 夜间模式生效 */[data-theme="dark"] #site-name,[data-theme="dark"] #site-title {  animation: light_15px 10s linear infinite;}[data-theme="dark"] #site-subtitle {  animation: light_10px 10s linear infinite;}[data-theme="dark"] #post-info {  animation: light_5px 10s linear infinite;}/* 关键帧描述 */@keyframes light_15px {  0% {    text-shadow: #5636ed 0 0 15px;  }  12.5% {    text-shadow: #11ee5e 0 0 15px;  }  25% {    text-shadow: #f14747 0 0 15px;  }  37.5% {    text-shadow: #f1a247 0 0 15px;  }  50% {    text-shadow: #f1ee47 0 0 15px;  }  50% {    text-shadow: #b347f1 0 0 15px;  }  62.5% {    text-shadow: #002afa 0 0 15px;  }  75% {    text-shadow: #ed709b 0 0 15px;  }  87.5% {    text-shadow: #39c5bb 0 0 15px;  }  100% {    text-shadow: #5636ed 0 0 15px;  }}@keyframes light_10px {  0% {    text-shadow: #5636ed 0 0 10px;  }  12.5% {    text-shadow: #11ee5e 0 0 10px;  }  25% {    text-shadow: #f14747 0 0 10px;  }  37.5% {    text-shadow: #f1a247 0 0 10px;  }  50% {    text-shadow: #f1ee47 0 0 10px;  }  50% {    text-shadow: #b347f1 0 0 10px;  }  62.5% {    text-shadow: #002afa 0 0 10px;  }  75% {    text-shadow: #ed709b 0 0 10px;  }  87.5% {    text-shadow: #39c5bb 0 0 10px;  }  100% {    text-shadow: #5636ed 0 0 10px;  }}@keyframes light_5px {  0% {    text-shadow: #5636ed 0 0 5px;  }  12.5% {    text-shadow: #11ee5e 0 0 5px;  }  25% {    text-shadow: #f14747 0 0 5px;  }  37.5% {    text-shadow: #f1a247 0 0 15px;  }  50% {    text-shadow: #f1ee47 0 0 5px;  }  50% {    text-shadow: #b347f1 0 0 5px;  }  62.5% {    text-shadow: #002afa 0 0 5px;  }  75% {    text-shadow: #ed709b 0 0 5px;  }  87.5% {    text-shadow: #39c5bb 0 0 5px;  }  100% {    text-shadow: #5636ed 0 0 5px;  }}@font-face {  /* 为载入的字体取名字(随意) */  font-family: 'YSHST';  /* 字体文件地址(相对或者绝对路径都可以) */  src: url(/font/优设好身体.woff2);  /* 定义加粗样式(加粗多少) */  font-weight: normal;  /* 定义字体样式(斜体/非斜体) */  font-style: normal;  /* 定义显示样式 */  font-display: block;}/* 翻页按钮居中 */#pagination {  width: 100%;  margin: auto;}/* 引入Unicode Font-class的线上资源*/@import "//at.alicdn.com/t/c/font_4217822_8n3z6c434px.css";/* 图标大小 */svg.icon {  width: 1.30em;  height: 1.30em;  vertical-align: -0.15em;  fill: currentColor;  overflow: hidden;}]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/css/rightmenu.css"/>
      <url>/css/rightmenu.css</url>
      
        <content type="html"><![CDATA[/* 右键菜单 */#rightMenu {    display: none;    position: fixed;    width: 160px;    height: fit-content;    top: 10%;    left: 10%;      /* 菜单面板背景色 */    background-color: var(--card-bg);      /* 菜单面板文字颜色 */    border: 1px solid var(--font-color);    border-radius: 8px;    z-index: 100;  }  #rightMenu .rightMenu-group {    padding: 7px 6px;  }  #rightMenu .rightMenu-group:not(:nth-last-child(1)) {    border-bottom: 1px solid var(--font-color);  }  #rightMenu .rightMenu-group.rightMenu-small {    display: flex;    justify-content: space-between;  }  #rightMenu .rightMenu-group .rightMenu-item {    height: 30px;    line-height: 30px;    border-radius: 8px;    transition: 0.3s;    color: var(--font-color);  }  #rightMenu .rightMenu-group.rightMenu-line .rightMenu-item {    display: flex;    height: 40px;    line-height: 40px;    padding: 0 4px;  }  #rightMenu .rightMenu-group .rightMenu-item:hover {      /* 鼠标悬浮选项颜色 */    background-color: var(--text-bg-hover);  }  #rightMenu .rightMenu-group .rightMenu-item i {    display: inline-block;    text-align: center;    line-height: 30px;    width: 30px;    height: 30px;    padding: 0 5px;  }  #rightMenu .rightMenu-group .rightMenu-item span {    line-height: 30px;  }    #rightMenu .rightMenu-group.rightMenu-line .rightMenu-item * {    height: 40px;    line-height: 40px;  }  .rightMenu-group.hide {    display: none;  }]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/css/universe.css"/>
      <url>/css/universe.css</url>
      
        <content type="html"><![CDATA[/* 背景宇宙星光  */#universe{    display: block;    position: fixed;    margin: 0;    padding: 0;    border: 0;    outline: 0;    left: 0;    top: 0;    width: 100%;    height: 100%;    pointer-events: none;    /* 这个是调置顶的优先级的，-1在文章页下面，背景上面，个人推荐这种 */    z-index: -1;  }]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>分类</title>
      <link href="/categories/index.html"/>
      <url>/categories/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/css/runtime.css"/>
      <url>/css/runtime.css</url>
      
        <content type="html"><![CDATA[/*电子钟字体*/@font-face {    font-family: 'UnidreamLED';    src: url("https://cdn.jsdelivr.net/npm/akilar-candyassets/fonts/UnidreamLED.ttf");    font-display: swap;  }  div#runtime {    width: 180px;    margin: auto;    color: #fff;    padding-inline: 5px;    border-radius: 10px;    background-color: rgba(0,0,0,0.7);    font-family: 'UnidreamLED';  }  [data-theme="dark"] div#runtime {    color: #28b4c8;    box-shadow: 0 0 5px rgba(28,69,218,0.71);    animation: flashlight 1s linear infinite alternate;  }  /*悬停显示徽标提示语*/  a.github-badge:hover:before {    position: fixed;    width: fit-content;    margin: auto;    left: 0;    right: 0;    top: 10%;    border-radius: 10px;    text-align: center;    z-index: 100;    content: attr(data-title);    font-size: 20px;    color: #fff;    padding: 10px;    background-color: var(--text-bg-hover);  }  [data-theme=dark] a.github-badge:hover:before {    background-color: rgba(18,18,18,0.8);  }  @-moz-keyframes flashlight {    from {      box-shadow: 0 0 5px #1478d2;    }    to {      box-shadow: 0 0 2px #1478d2;    }  }  @-webkit-keyframes flashlight {    from {      box-shadow: 0 0 5px #1478d2;    }    to {      box-shadow: 0 0 2px #1478d2;    }  }  @-o-keyframes flashlight {    from {      box-shadow: 0 0 5px #1478d2;    }    to {      box-shadow: 0 0 2px #1478d2;    }  }  @keyframes flashlight {    from {      box-shadow: 0 0 5px #1478d2;    }    to {      box-shadow: 0 0 2px #1478d2;    }  }]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/js/cursor.js"/>
      <url>/js/cursor.js</url>
      
        <content type="html"><![CDATA[var CURSOR;Math.lerp = (a, b, n) => (1 - n) * a + n * b;const getStyle = (el, attr) => {    try {        return window.getComputedStyle            ? window.getComputedStyle(el)[attr]            : el.currentStyle[attr];    } catch (e) {}    return "";};class Cursor {    constructor() {        this.pos = {curr: null, prev: null};        this.pt = [];        this.create();        this.init();        this.render();    }    move(left, top) {        this.cursor.style["left"] = `${left}px`;        this.cursor.style["top"] = `${top}px`;    }    create() {        if (!this.cursor) {            this.cursor = document.createElement("div");            this.cursor.id = "cursor";            this.cursor.classList.add("hidden");            document.body.append(this.cursor);        }        var el = document.getElementsByTagName('*');        for (let i = 0; i < el.length; i++)            if (getStyle(el[i], "cursor") == "pointer")                this.pt.push(el[i].outerHTML);        document.body.appendChild((this.scr = document.createElement("style")));        // 这里改变鼠标指针的颜色 由svg生成        this.scr.innerHTML = `* {cursor: url("data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 8 8' width='8px' height='8px'><circle cx='4' cy='4' r='4' opacity='1.0' fill='rgb(57, 197, 187)'/></svg>") 4 4, auto}`;    }    refresh() {        this.scr.remove();        this.cursor.classList.remove("hover");        this.cursor.classList.remove("active");        this.pos = {curr: null, prev: null};        this.pt = [];        this.create();        this.init();        this.render();    }    init() {        document.onmouseover  = e => this.pt.includes(e.target.outerHTML) && this.cursor.classList.add("hover");        document.onmouseout   = e => this.pt.includes(e.target.outerHTML) && this.cursor.classList.remove("hover");        document.onmousemove  = e => {(this.pos.curr == null) && this.move(e.clientX - 8, e.clientY - 8); this.pos.curr = {x: e.clientX - 8, y: e.clientY - 8}; this.cursor.classList.remove("hidden");};        document.onmouseenter = e => this.cursor.classList.remove("hidden");        document.onmouseleave = e => this.cursor.classList.add("hidden");        document.onmousedown  = e => this.cursor.classList.add("active");        document.onmouseup    = e => this.cursor.classList.remove("active");    }    render() {        if (this.pos.prev) {            this.pos.prev.x = Math.lerp(this.pos.prev.x, this.pos.curr.x, 0.15);            this.pos.prev.y = Math.lerp(this.pos.prev.y, this.pos.curr.y, 0.15);            this.move(this.pos.prev.x, this.pos.prev.y);        } else {            this.pos.prev = this.pos.curr;        }        requestAnimationFrame(() => this.render());    }}(() => {    CURSOR = new Cursor();    // 需要重新获取列表时，使用 CURSOR.refresh()})();]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/js/runtime.js"/>
      <url>/js/runtime.js</url>
      
        <content type="html"><![CDATA[setInterval(() => {    let create_time = Math.round(new Date('2023-08-18 00:00:00').getTime() / 1000); //在此行修改建站时间    let timestamp = Math.round((new Date().getTime()) / 1000);    let second = timestamp - create_time;    let time = new Array(0, 0, 0, 0, 0);      var nol = function(h){      return h>9?h:'0'+h;    }    if (second >= 365 * 24 * 3600) {      time[0] = parseInt(second / (365 * 24 * 3600));      second %= 365 * 24 * 3600;    }    if (second >= 24 * 3600) {      time[1] = parseInt(second / (24 * 3600));      second %= 24 * 3600;    }    if (second >= 3600) {      time[2] = nol(parseInt(second / 3600));      second %= 3600;    }    if (second >= 60) {      time[3] = nol(parseInt(second / 60));      second %= 60;    }    if (second > 0) {      time[4] = nol(second);    }    if ((Number(time[2])<22) && (Number(time[2])>7)){      currentTimeHtml ="<img class='boardsign' src='https://img.shields.io/badge/糖果屋-营业中-6adea8?style=social&logo=cakephp' title='距离百年老店也就差不到一百年~'><div id='runtime'>" + time[0] + ' YEAR ' + time[1] + ' DAYS ' + time[2] + ' : ' + time[3] + ' : ' + time[4] + '</div>';    }    else{      currentTimeHtml ="<img class='boardsign' src='https://img.shields.io/badge/糖果屋-打烊了-6adea8?style=social&logo=coffeescript' title='这个点了应该去睡觉啦，熬夜对身体不好哦'><div id='runtime'>" + time[0] + ' YEAR ' + time[1] + ' DAYS ' + time[2] + ' : ' + time[3] + ' : ' + time[4] + '</div>';    }    document.getElementById("workboard").innerHTML = currentTimeHtml;  }, 1000);]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/js/title.js"/>
      <url>/js/title.js</url>
      
        <content type="html"><![CDATA[//动态标题var OriginTitile = document.title;var titleTime;document.addEventListener('visibilitychange', function () {    if (document.hidden) {        //离开当前页面时标签显示内容        document.title = 'w(ﾟДﾟ)w 不要走！再看看嘛！';        clearTimeout(titleTime);    }    else {        //返回当前页面时标签显示内容        document.title = '♪(^∇^*)欢迎回来！' + OriginTitile;        //两秒后变回正常标题        titleTime = setTimeout(function () {            document.title = OriginTitile;        }, 2000);    }});]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/js/universe.js"/>
      <url>/js/universe.js</url>
      
        <content type="html"><![CDATA[function dark() {window.requestAnimationFrame=window.requestAnimationFrame||window.mozRequestAnimationFrame||window.webkitRequestAnimationFrame||window.msRequestAnimationFrame;var n,e,i,h,t=.05,s=document.getElementById("universe"),o=!0,a="180,184,240",r="226,225,142",d="226,225,224",c=[];function f(){n=window.innerWidth,e=window.innerHeight,i=.216*n,s.setAttribute("width",n),s.setAttribute("height",e)}function u(){h.clearRect(0,0,n,e);for(var t=c.length,i=0;i<t;i++){var s=c[i];s.move(),s.fadeIn(),s.fadeOut(),s.draw()}}function y(){this.reset=function(){this.giant=m(3),this.comet=!this.giant&&!o&&m(10),this.x=l(0,n-10),this.y=l(0,e),this.r=l(1.1,2.6),this.dx=l(t,6*t)+(this.comet+1-1)*t*l(50,120)+2*t,this.dy=-l(t,6*t)-(this.comet+1-1)*t*l(50,120),this.fadingOut=null,this.fadingIn=!0,this.opacity=0,this.opacityTresh=l(.2,1-.4*(this.comet+1-1)),this.do=l(5e-4,.002)+.001*(this.comet+1-1)},this.fadeIn=function(){this.fadingIn&&(this.fadingIn=!(this.opacity>this.opacityTresh),this.opacity+=this.do)},this.fadeOut=function(){this.fadingOut&&(this.fadingOut=!(this.opacity<0),this.opacity-=this.do/2,(this.x>n||this.y<0)&&(this.fadingOut=!1,this.reset()))},this.draw=function(){if(h.beginPath(),this.giant)h.fillStyle="rgba("+a+","+this.opacity+")",h.arc(this.x,this.y,2,0,2*Math.PI,!1);else if(this.comet){h.fillStyle="rgba("+d+","+this.opacity+")",h.arc(this.x,this.y,1.5,0,2*Math.PI,!1);for(var t=0;t<30;t++)h.fillStyle="rgba("+d+","+(this.opacity-this.opacity/20*t)+")",h.rect(this.x-this.dx/4*t,this.y-this.dy/4*t-2,2,2),h.fill()}else h.fillStyle="rgba("+r+","+this.opacity+")",h.rect(this.x,this.y,this.r,this.r);h.closePath(),h.fill()},this.move=function(){this.x+=this.dx,this.y+=this.dy,!1===this.fadingOut&&this.reset(),(this.x>n-n/4||this.y<0)&&(this.fadingOut=!0)},setTimeout(function(){o=!1},50)}function m(t){return Math.floor(1e3*Math.random())+1<10*t}function l(t,i){return Math.random()*(i-t)+t}f(),window.addEventListener("resize",f,!1),function(){h=s.getContext("2d");for(var t=0;t<i;t++)c[t]=new y,c[t].reset();u()}(),function t(){document.getElementsByTagName('html')[0].getAttribute('data-theme')=='dark'&&u(),window.requestAnimationFrame(t)}()};dark()]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>友链</title>
      <link href="/link/index.html"/>
      <url>/link/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>电影</title>
      <link href="/movie/index.html"/>
      <url>/movie/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>标签</title>
      <link href="/tags/index.html"/>
      <url>/tags/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>音乐</title>
      <link href="/music/index.html"/>
      <url>/music/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
  
</search>
